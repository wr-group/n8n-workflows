{
  "updatedAt": "2026-02-11T00:07:50.474Z",
  "createdAt": "2026-02-03T01:37:20.611Z",
  "id": "NXvUDPpKfGxWETqO",
  "name": "02. Email Lead Managment v4",
  "description": null,
  "active": true,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "13lFnQiBUmo1W0oQoTNlcn94ouflhuRWlMYu9NQV7taQ",
          "mode": "list",
          "cachedResultName": "Leads Logs",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/13lFnQiBUmo1W0oQoTNlcn94ouflhuRWlMYu9NQV7taQ/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "raw",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/13lFnQiBUmo1W0oQoTNlcn94ouflhuRWlMYu9NQV7taQ/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Timestamp": "={{ $json.Timestamp }}",
            "Id": "={{ $json.Id }}",
            "Lead Type": "={{ $json['Lead Type'] }}",
            "First Name": "={{ $json['First Name'] }}",
            "Last Name": "={{ $json['Last Name'] }}",
            "Mobile Number": "={{ $json['Mobile Number'] }}",
            "Phone Number": "={{ $json['Phone Number'] }}",
            "Email Address": "={{ $json['Email Address'] }}",
            "Address": "={{ $json.Address }}",
            "State": "={{ $json.State }}",
            "Suburb": "={{ $json.Suburb }}",
            "Postal Code": "={{ $json['Postal Code'] }}",
            "Enquiry": "={{ $json.Enquiry }}",
            "Quantity": "={{ $json.Quantity }}",
            "Iâ€™d Like To Get My Project Underway": "={{ $json['I\\'d Like To Get My Project Underway'] }}",
            "How they heard about us": "={{ $json['How they heard about us'] }}",
            "Lead Qualifier": "={{ $json['Lead Qualifier'] }}",
            "Referred By": "={{ $json.referredBy }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "Timestamp",
              "displayName": "Timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Id",
              "displayName": "Id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Lead Type",
              "displayName": "Lead Type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "First Name",
              "displayName": "First Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Last Name",
              "displayName": "Last Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Mobile Number",
              "displayName": "Mobile Number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Phone Number",
              "displayName": "Phone Number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Email Address",
              "displayName": "Email Address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Address",
              "displayName": "Address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "State",
              "displayName": "State",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Suburb",
              "displayName": "Suburb",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Postal Code",
              "displayName": "Postal Code",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Enquiry",
              "displayName": "Enquiry",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Quantity",
              "displayName": "Quantity",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Iâ€™d Like To Get My Project Underway",
              "displayName": "Iâ€™d Like To Get My Project Underway",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "How they heard about us",
              "displayName": "How they heard about us",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Lead Qualifier",
              "displayName": "Lead Qualifier",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Referred By",
              "displayName": "Referred By",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {
          "useAppend": true
        }
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        3504,
        -320
      ],
      "id": "c88d9cab-c774-4e52-af35-78fa7f6136cc",
      "name": "Append row in sheet",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "S4FmXrss6MgN5rzt",
          "name": "WR: Google Sheets Account"
        }
      }
    },
    {
      "parameters": {
        "operation": "addLabels",
        "messageId": "={{ $json.Id }}",
        "labelIds": [
          "Label_169"
        ]
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        4176,
        -320
      ],
      "id": "72138bd5-c98c-49d0-bb1b-7e8c1923eea2",
      "name": "Add label to message",
      "webhookId": "d223a823-9177-4c4e-b398-48b487c46935",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "61b9b0d9-8451-470a-a782-ccf3201f846d",
              "leftValue": "={{ $json['Lead Qualifier'] }}",
              "rightValue": "Good",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        3728,
        -320
      ],
      "id": "fef28829-9863-4e53-8bad-e86424f7e7fa",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "// =============== Helpers ===============\n\nfunction normalizeDigits(str) {\n  if (!str) return '';\n  return String(str).replace(/\\D+/g, '');\n}\n\n// Normalise any AU-looking phone number\nfunction normalizeAuPhone(raw) {\n  let digits = normalizeDigits(raw);\n  if (!digits) return '';\n\n  if (digits.startsWith('61')) {\n    digits = '0' + digits.slice(2);\n  }\n\n  if (!digits.startsWith('0') && digits.length === 9 && digits.startsWith('4')) {\n    digits = '0' + digits;\n  }\n\n  return digits;\n}\n\nfunction formatAuPhoneFromDigits(digits) {\n  if (!digits) return '';\n\n  if (digits.length === 10 && digits.startsWith('04')) {\n    return digits.replace(/(\\d{4})(\\d{3})(\\d{3})/, '$1 $2 $3');\n  }\n\n  if (digits.length === 10 && digits.startsWith('0')) {\n    return digits.replace(/(\\d{2})(\\d{4})(\\d{4})/, '$1 $2 $3');\n  }\n\n  return digits;\n}\n\nfunction getExecutionTimes() {\n  const now = new Date();\n  return {\n    executionBrisbane: now.toLocaleString('en-AU', {\n      timeZone: 'Australia/Brisbane',\n      hour12: false,\n    }),\n  };\n}\n\n// =============== ðŸ”’ PRIVYR SUMMARY DETECTION (NEW) ===============\n// These emails are NOT leads and must be ignored entirely\nfunction isPrivyrSummaryEmail(rawText) {\n  if (!rawText) return false;\n\n  const t = rawText.toLowerCase();\n\n  return (\n    t.includes('daily summary') ||\n    t.includes('uncontacted leads') ||\n    t.includes('upcoming activities') ||\n    t.includes('view all uncontacted leads') ||\n    t.includes('open privyr')\n  );\n}\n\n// -------------------- Spam Rules (UNCHANGED) --------------------\nconst BAD_NAME_WORDS = new Set([\n  'test','asdf','qwer','zxcv','xxxx','abc','123','sdr','null','none','na','n/a','demo'\n]);\n\nconst DISPOSABLE_DOMAINS = new Set([\n  'mailinator.com','tempmail.com','10minutemail.com','guerrillamail.com',\n  'yopmail.com','trashmail.com','sharklasers.com','getnada.com'\n]);\n\nfunction isLikelyGibberishName(name) {\n  const s = String(name || '').trim().toLowerCase();\n  if (!s) return true;\n\n  const cleaned = s.replace(/[^a-z\\s'\\-]/g, '');\n  const lettersOnly = cleaned.replace(/[^a-z]/g, '');\n\n  if (lettersOnly.length < 2) return true;\n  if (cleaned.length < s.length * 0.7) return true;\n\n  const vowels = (lettersOnly.match(/[aeiou]/g) || []).length;\n  const vowelRatio = vowels / lettersOnly.length;\n\n  const hasLongRepeat = /(.)\\1{3,}/.test(lettersOnly);\n  const hasConsonantRun = /[bcdfghjklmnpqrstvwxyz]{5,}/.test(lettersOnly);\n\n  if (lettersOnly.length <= 5) {\n    if (hasLongRepeat) return true;\n    if (hasConsonantRun && lettersOnly.length >= 5) return true;\n    return false;\n  }\n\n  if (vowelRatio < 0.22 || hasConsonantRun || hasLongRepeat) return true;\n  return false;\n}\n\nfunction hasBadNameWord(first, last) {\n  const f = String(first || '').trim().toLowerCase();\n  const l = String(last || '').trim().toLowerCase();\n  return BAD_NAME_WORDS.has(f) || BAD_NAME_WORDS.has(l) || (f + ' ' + l).includes('test');\n}\n\nfunction isDisposableEmail(email) {\n  const e = String(email || '').trim().toLowerCase();\n  const m = e.match(/@([a-z0-9.-]+\\.[a-z]{2,})$/);\n  return m ? DISPOSABLE_DOMAINS.has(m[1]) : false;\n}\n\nfunction isFakePhoneDigits(digits) {\n  const d = normalizeDigits(digits);\n  if (!d) return true;\n  if (d.length < 9) return true;\n  if (/^(\\d)\\1+$/.test(d)) return true;\n  if (d.includes('123456') || d.includes('00000')) return true;\n  return false;\n}\n\nfunction isSpamLead(parsed, mobileFormatted, phoneFormatted) {\n  const first = (parsed.firstName || '').trim();\n  const last  = (parsed.lastName  || '').trim();\n  const email = (parsed.email || '').trim();\n\n  const hasName = first.length >= 2 && last.length >= 2;\n\n  const mobileDigits = normalizeDigits(mobileFormatted || '');\n  const phoneDigits  = normalizeDigits(phoneFormatted || '');\n  const hasAnyPhone  = mobileDigits.length > 0 || phoneDigits.length > 0;\n\n  if (!hasName) return true;\n  if (!hasAnyPhone) return true;\n  if (hasBadNameWord(first, last)) return true;\n  if (isLikelyGibberishName(first) || isLikelyGibberishName(last)) return true;\n  if (email && isDisposableEmail(email)) return true;\n  if (isFakePhoneDigits(mobileDigits || phoneDigits)) return true;\n\n  return false;\n}\n\n// =============== Facebook Parser (UNCHANGED) ===============\n\nfunction parseFacebookText(rawText) {\n  if (!rawText) return {};\n  const text = rawText.replace(/\\s+/g, ' ');\n\n  const markerDefs = [\n    { key: 'comments',       marker: 'Comments/Questions:' },\n    { key: 'email',          marker: 'Email:' },\n    { key: 'firstName',      marker: 'First Name:' },\n    { key: 'lastName',       marker: 'Last Name:' },\n    { key: 'mobileRaw',      marker: 'Mobile Number:' },\n    { key: 'phoneNumberRaw', marker: 'Phone Number:' },\n    { key: 'service',        marker: 'Please Select What You Want Fixing::' },\n    { key: 'quantity',       marker: 'Quantity:' },\n    { key: 'timeFrame',      marker: 'Time Frame For Repairs?:' },\n    { key: 'suburb',         marker: 'Which Suburb?:' },\n  ];\n\n  const positions = [];\n  for (const m of markerDefs) {\n    const idx = text.indexOf(m.marker);\n    if (idx !== -1) {\n      positions.push({ key: m.key, markerIndex: idx, valueStart: idx + m.marker.length });\n    }\n  }\n\n  if (!positions.length) return {};\n\n  positions.sort((a, b) => a.markerIndex - b.markerIndex);\n\n  const result = {};\n  for (let i = 0; i < positions.length; i++) {\n    const curr = positions[i];\n    const next = positions[i + 1];\n    const end  = next ? next.markerIndex : text.length;\n    const value = text.slice(curr.valueStart, end).trim();\n    if (curr.key && value) result[curr.key] = value;\n  }\n\n  if (!result.email) {\n    const emailMatch = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n    if (emailMatch) result.email = emailMatch[0];\n  }\n\n  return result;\n}\n\n// =============== MAIN (WITH FILTER) ===============\n\nconst execTime = getExecutionTimes();\n\nreturn items\n  // ðŸš« HARD FILTER: ignore Privyr summary emails entirely\n  .filter(item => {\n    const rawText = item.json?.text || item.json?.textHtml || item.json?.snippet || '';\n    return !isPrivyrSummaryEmail(rawText);\n  })\n  .map(item => {\n    const json    = item.json || {};\n    const id      = json.id || '';\n    const rawText = json.text || json.textHtml || json.snippet || '';\n\n    const parsed = parseFacebookText(rawText);\n\n    let mobileFormatted = '';\n    let phoneFormatted  = '';\n\n    const mobileDigits = normalizeAuPhone(parsed.mobileRaw || '');\n    const phoneDigits  = normalizeAuPhone(parsed.phoneNumberRaw || '');\n\n    if (mobileDigits) {\n      mobileFormatted = mobileDigits.startsWith('04')\n        ? formatAuPhoneFromDigits(mobileDigits)\n        : mobileDigits;\n    }\n\n    if (phoneDigits) {\n      if (phoneDigits.startsWith('04')) {\n        mobileFormatted ||= formatAuPhoneFromDigits(phoneDigits);\n      } else {\n        phoneFormatted = phoneDigits.startsWith('0')\n          ? formatAuPhoneFromDigits(phoneDigits)\n          : phoneDigits;\n      }\n    }\n\n    const leadQualifier = isSpamLead(parsed, mobileFormatted, phoneFormatted) ? 'Spam' : 'Good';\n\n    return {\n      json: {\n        Timestamp: execTime.executionBrisbane,\n        Id: id,\n        'Lead Type': 'Facebook Lead',\n        'First Name': parsed.firstName || '',\n        'Last Name': parsed.lastName || '',\n        'Mobile Number': mobileFormatted,\n        'Phone Number': phoneFormatted,\n        'Email Address': parsed.email || '',\n        Address: '',\n        State: '',\n        Suburb: parsed.suburb || '',\n        'Postal Code': '',\n        Enquiry: parsed.comments || parsed.service || '',\n        Quantity: parsed.quantity || '',\n        \"I'd Like To Get My Project Underway\": parsed.timeFrame || '',\n        'How they heard about us': 'Facebook Marketing',\n        'Lead Qualifier': leadQualifier,\n      },\n    };\n  });\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3280,
        -304
      ],
      "id": "ee8ae6c2-4a7e-4e38-aa54-d98a168eef11",
      "name": "FB Parsing"
    },
    {
      "parameters": {
        "jsCode": "// items: array of input items from Gmail Get Many\n// each item.json has at least: { id, text }\n\n// =================== Utilities ===================\n\nfunction normalizeDigits(str) {\n  if (!str) return '';\n  return String(str).replace(/\\D+/g, '');\n}\n\nfunction formatAuPhone(raw, type) {\n  if (!raw) return '';\n  let digits = normalizeDigits(raw);\n  if (!digits) return '';\n\n  if (digits.startsWith('61')) {\n    digits = '0' + digits.slice(2);\n  } else if (!digits.startsWith('0') && digits.length >= 9) {\n    digits = '0' + digits;\n  }\n\n  if (type === 'mobile' && digits.length === 10) {\n    return digits.replace(/(\\d{4})(\\d{3})(\\d{3})/, '$1 $2 $3');\n  }\n\n  if (type === 'landline' && digits.length === 10) {\n    return digits.replace(/(\\d{2})(\\d{4})(\\d{4})/, '$1 $2 $3');\n  }\n\n  return digits;\n}\n\nfunction getBrisbaneDate(json) {\n  const date = json.internalDate ? new Date(Number(json.internalDate)) : new Date();\n  return date.toLocaleString('en-AU', { timeZone: 'Australia/Brisbane', hour12: false });\n}\n\n// =================== CLEAN PROJECT TIMING ===================\n\nfunction cleanProjectTiming(value) {\n  if (!value) return '';\n\n  const STOP_WORDS = [\n    'How did yopu here about us',\n    'How did you hear about us',\n    'How they heard about us',\n    'Services',\n    'Brands'\n  ];\n\n  let cleaned = value;\n\n  // Cut at known boundaries\n  for (const stop of STOP_WORDS) {\n    const idx = cleaned.indexOf(stop);\n    if (idx !== -1) {\n      cleaned = cleaned.slice(0, idx);\n    }\n  }\n\n  // Remove Gmail / HTML junk like \"...\"\n  cleaned = cleaned\n    .replace(/^\\s*\\.{2,}/, '')   // remove \"..\" / \"...\"\n    .replace(/^[\\s:â€“â€”-]+/, '')   // leading punctuation\n    .trim();\n\n  // If only dots existed, return empty\n  if (/^\\.*$/.test(cleaned)) return '';\n\n  return cleaned;\n}\n\n// =================== Parser ===================\n\nfunction parseFormText(rawText) {\n  if (!rawText) return {};\n\n  const text = rawText.replace(/\\r?\\n/g, ' ');\n\n  const markerDefs = [\n    { key: 'firstName',      marker: 'First Name' },\n    { key: 'lastName',       marker: 'Last Name' },\n    { key: 'email',          marker: 'Email' },\n    { key: 'mobileRaw',      marker: 'Mobile Number' },\n    { key: 'phoneNumberRaw', marker: 'Phone Number' },\n    { key: 'address',        marker: 'Address' },\n    { key: 'suburb',         marker: 'Suburb' },\n    { key: 'state',          marker: 'State' },\n    { key: 'postalCode',     marker: 'Postal Code' },\n    { key: 'enquiry',        marker: 'Enquiry' },\n    { key: 'projectTiming',  marker: \"I'd Like To Get My Project Underway\" },\n    { key: 'quantity',       marker: 'Quantity' },\n\n    // Boundaries\n    { key: null, marker: 'How did yopu here about us' },\n    { key: null, marker: 'How did you hear about us' },\n    { key: null, marker: 'How they heard about us' },\n    { key: null, marker: 'Brands' },\n    { key: null, marker: 'Services' }\n  ];\n\n  const positions = [];\n  for (const m of markerDefs) {\n    const idx = text.indexOf(m.marker);\n    if (idx === -1) continue;\n    positions.push({ key: m.key, markerIndex: idx, valueStart: idx + m.marker.length });\n  }\n\n  if (!positions.length) return {};\n\n  positions.sort((a, b) => a.markerIndex - b.markerIndex);\n\n  const result = {};\n  for (let i = 0; i < positions.length; i++) {\n    const curr = positions[i];\n    const next = positions[i + 1];\n    const end = next ? next.markerIndex : text.length;\n    const value = text.slice(curr.valueStart, end).trim();\n    if (curr.key && value && !result[curr.key]) result[curr.key] = value;\n  }\n\n  if (!result.email) {\n    const emailMatch = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n    if (emailMatch) result.email = emailMatch[0];\n  }\n\n  return result;\n}\n\n// =================== Spam Rules ===================\n\nconst BAD_NAME_WORDS = new Set([\n  'test','asdf','qwer','zxcv','xxxx','abc','123','sdr','null','none','na','n/a','demo'\n]);\n\nconst DISPOSABLE_DOMAINS = new Set([\n  'mailinator.com','tempmail.com','10minutemail.com','guerrillamail.com',\n  'yopmail.com','trashmail.com','sharklasers.com','getnada.com'\n]);\n\nfunction isLikelyGibberishName(name) {\n  const s = String(name || '').trim().toLowerCase();\n  if (!s) return true;\n\n  const cleaned = s.replace(/[^a-z\\s'\\-]/g, '');\n  const lettersOnly = cleaned.replace(/[^a-z]/g, '');\n\n  if (lettersOnly.length < 2) return true;\n  if (cleaned.length < s.length * 0.7) return true;\n\n  const vowels = (lettersOnly.match(/[aeiou]/g) || []).length;\n  const vowelRatio = vowels / lettersOnly.length;\n  const hasLongRepeat = /(.)\\1{3,}/.test(lettersOnly);\n  const hasConsonantRun = /[bcdfghjklmnpqrstvwxyz]{5,}/.test(lettersOnly);\n\n  if (lettersOnly.length <= 5) {\n    if (hasLongRepeat) return true;\n    if (hasConsonantRun && lettersOnly.length >= 5) return true;\n    return false;\n  }\n\n  if (vowelRatio < 0.22 || hasConsonantRun || hasLongRepeat) return true;\n  return false;\n}\n\nfunction hasBadNameWord(first, last) {\n  const f = String(first || '').toLowerCase();\n  const l = String(last || '').toLowerCase();\n  return BAD_NAME_WORDS.has(f) || BAD_NAME_WORDS.has(l) || (f + ' ' + l).includes('test');\n}\n\nfunction isDisposableEmail(email) {\n  const m = String(email || '').toLowerCase().match(/@([a-z0-9.-]+\\.[a-z]{2,})$/);\n  return m ? DISPOSABLE_DOMAINS.has(m[1]) : false;\n}\n\nfunction isFakePhoneDigits(digits) {\n  const d = normalizeDigits(digits);\n  if (!d || d.length < 9) return true;\n  if (/^(\\d)\\1+$/.test(d)) return true;\n  if (d.includes('123456') || d.includes('00000')) return true;\n  return false;\n}\n\nfunction isSpamLead(parsed, mobileFormatted, phoneFormatted) {\n  const first = (parsed.firstName || '').trim();\n  const last  = (parsed.lastName  || '').trim();\n  const email = (parsed.email || '').trim();\n\n  const mobileDigits = normalizeDigits(mobileFormatted || '');\n  const phoneDigits  = normalizeDigits(phoneFormatted || '');\n  const hasAnyPhone = mobileDigits.length > 0 || phoneDigits.length > 0;\n\n  if (first.length < 2 || last.length < 2) return true;\n  if (!hasAnyPhone) return true;\n  if (hasBadNameWord(first, last)) return true;\n  if (isLikelyGibberishName(first) || isLikelyGibberishName(last)) return true;\n  if (email && isDisposableEmail(email)) return true;\n  if (isFakePhoneDigits(mobileDigits || phoneDigits)) return true;\n\n  return false;\n}\n\n// =================== MAIN ===================\n\nreturn items.map(item => {\n  const json = item.json || {};\n  const rawText = json.text || json.textPlain || json.snippet || '';\n  const parsed = parseFormText(rawText);\n\n  let mobileFormatted = '';\n  let phoneFormatted  = '';\n\n  if (parsed.mobileRaw) {\n    mobileFormatted = formatAuPhone(parsed.mobileRaw, 'mobile');\n  }\n\n  if (parsed.phoneNumberRaw) {\n    const digits = normalizeDigits(parsed.phoneNumberRaw);\n    if (digits.startsWith('04')) {\n      mobileFormatted ||= formatAuPhone(parsed.phoneNumberRaw, 'mobile');\n    } else {\n      phoneFormatted = formatAuPhone(parsed.phoneNumberRaw, 'landline');\n    }\n  }\n\n  const leadQualifier = isSpamLead(parsed, mobileFormatted, phoneFormatted) ? 'Spam' : 'Good';\n\n  return {\n    json: {\n      Timestamp: getBrisbaneDate(json),\n      Id: json.id || '',\n\n      'Lead Type': 'Windowrevival.NET Lead',\n\n      'First Name': parsed.firstName || '',\n      'Last Name':  parsed.lastName  || '',\n      'Mobile Number': mobileFormatted,\n      'Phone Number':  phoneFormatted,\n      'Email Address': parsed.email || '',\n      'Address': parsed.address || '',\n      State: parsed.state || '',\n      Suburb: parsed.suburb || '',\n      'Postal Code': parsed.postalCode || '',\n      Enquiry: parsed.enquiry || '',\n      Quantity: parsed.quantity || '',\n\n      // âœ… FIXED FIELD\n      \"I'd Like To Get My Project Underway\": cleanProjectTiming(parsed.projectTiming),\n\n      'How they heard about us': 'WRnet Website',\n      'Lead Qualifier': leadQualifier,\n      referredBy: '',\n    },\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3280,
        -496
      ],
      "id": "d370cc05-05c3-4faa-a05b-952b06e94f87",
      "name": "Windowrevival.NET Parsing"
    },
    {
      "parameters": {
        "jsCode": "// =================== Utilities ===================\n\nfunction normalizeDigits(str) {\n  if (!str) return '';\n  return String(str).replace(/\\D+/g, '');\n}\n\nfunction formatAuPhone(raw, type) {\n  if (!raw) return '';\n  let digits = normalizeDigits(raw);\n  if (!digits) return '';\n\n  if (digits.startsWith('61')) {\n    digits = '0' + digits.slice(2);\n  } else if (!digits.startsWith('0') && digits.length >= 9) {\n    digits = '0' + digits;\n  }\n\n  if (type === 'mobile' && digits.length === 10) {\n    return digits.replace(/(\\d{4})(\\d{3})(\\d{3})/, '$1 $2 $3');\n  }\n\n  if (type === 'landline' && digits.length === 10) {\n    return digits.replace(/(\\d{2})(\\d{4})(\\d{4})/, '$1 $2 $3');\n  }\n\n  return digits;\n}\n\nfunction getBrisbaneDate(json) {\n  const date = json.internalDate ? new Date(Number(json.internalDate)) : new Date();\n  return date.toLocaleString('en-AU', { timeZone: 'Australia/Brisbane', hour12: false });\n}\n\n// =================== CLEAN PROJECT TIMING FIX ===================\n\nfunction cleanProjectTiming(value) {\n  if (!value) return '';\n\n  const STOP_WORDS = [\n    'How did yopu here about us',\n    'How did you hear about us',\n    'How they heard about us',\n    'Services',\n    'Brands'\n  ];\n\n  let cleaned = value;\n\n  for (const stop of STOP_WORDS) {\n    const idx = cleaned.indexOf(stop);\n    if (idx !== -1) cleaned = cleaned.slice(0, idx);\n  }\n\n  cleaned = cleaned\n    .replace(/^\\s*\\.{2,}/, '')\n    .replace(/^[\\s:â€“â€”-]+/, '')\n    .trim();\n\n  return cleaned;\n}\n\n// =================== Parser ===================\n\nfunction parseFormText(rawText) {\n  if (!rawText) return {};\n  const text = rawText.replace(/\\r?\\n/g, ' ');\n  const lower = text.toLowerCase();\n\n  const markerDefs = [\n    { key: 'firstName', marker: 'First Name' },\n    { key: 'lastName', marker: 'Last Name' },\n    { key: 'email', marker: 'Email' },\n    { key: 'mobileRaw', marker: 'Mobile Number' },\n    { key: 'phoneNumberRaw', marker: 'Phone Number' },\n    { key: 'suburb', marker: 'Suburb' },\n    { key: 'state', marker: 'State' },\n    { key: 'enquiry', marker: 'Enquiry' },\n    { key: 'projectTiming', marker: \"I'd Like To Get My Project Underway\" },\n    { key: 'quantity', marker: 'Quantity' }\n  ];\n\n  const positions = [];\n  for (const m of markerDefs) {\n    const idx = lower.indexOf(m.marker.toLowerCase());\n    if (idx !== -1) {\n      positions.push({ key: m.key, markerIndex: idx, valueStart: idx + m.marker.length });\n    }\n  }\n\n  if (!positions.length) return {};\n  positions.sort((a, b) => a.markerIndex - b.markerIndex);\n\n  const result = {};\n  for (let i = 0; i < positions.length; i++) {\n    const curr = positions[i];\n    const next = positions[i + 1];\n    const end = next ? next.markerIndex : text.length;\n    const value = text.slice(curr.valueStart, end).trim();\n    if (curr.key && value && !result[curr.key]) result[curr.key] = value;\n  }\n\n  if (!result.email) {\n    const emailMatch = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n    if (emailMatch) result.email = emailMatch[0];\n  }\n\n  return result;\n}\n\n// =================== Name handling (multi-word) ===================\n\nfunction splitFullName(firstRaw, lastRaw) {\n  const f = String(firstRaw || '').trim();\n  const l = String(lastRaw || '').trim();\n\n  if (f && l) return { firstName: f, lastName: l };\n\n  const full = (f || l).trim();\n  if (!full) return { firstName: '', lastName: '' };\n\n  const parts = full.split(/\\s+/).filter(Boolean);\n  if (parts.length === 1) return { firstName: parts[0], lastName: '' };\n  return { firstName: parts[0], lastName: parts.slice(1).join(' ') };\n}\n\n// =================== Spam Rules ===================\n\nconst BAD_NAME_WORDS = new Set([\n  'test','asdf','qwer','zxcv','xxxx','abc','123','sdr','null','none','na','n/a','demo'\n]);\n\nconst DISPOSABLE_DOMAINS = new Set([\n  'mailinator.com','tempmail.com','10minutemail.com','guerrillamail.com',\n  'yopmail.com','trashmail.com','sharklasers.com','getnada.com'\n]);\n\nfunction isLikelyGibberishName(name) {\n  const s = String(name || '').trim().toLowerCase();\n  if (!s) return true;\n\n  const cleaned = s.replace(/[^a-z\\s'\\-]/g, '');\n  const lettersOnly = cleaned.replace(/[^a-z]/g, '');\n\n  if (lettersOnly.length < 2) return true;\n  if (cleaned.length < s.length * 0.7) return true;\n\n  const vowels = (lettersOnly.match(/[aeiou]/g) || []).length;\n  const vowelRatio = vowels / lettersOnly.length;\n  const hasLongRepeat = /(.)\\1{3,}/.test(lettersOnly);\n  const hasConsonantRun = /[bcdfghjklmnpqrstvwxyz]{5,}/.test(lettersOnly);\n\n  // For very short tokens, avoid false positives\n  if (lettersOnly.length <= 5) {\n    if (hasLongRepeat) return true;\n    if (hasConsonantRun && lettersOnly.length >= 5) return true;\n    return false;\n  }\n\n  if (vowelRatio < 0.22 || hasConsonantRun || hasLongRepeat) return true;\n  return false;\n}\n\nfunction hasBadNameWord(first, last) {\n  const f = String(first || '').toLowerCase();\n  const l = String(last || '').toLowerCase();\n  return BAD_NAME_WORDS.has(f) || BAD_NAME_WORDS.has(l) || (f + ' ' + l).includes('test');\n}\n\nfunction isDisposableEmail(email) {\n  const m = String(email || '').toLowerCase().match(/@([a-z0-9.-]+\\.[a-z]{2,})$/);\n  return m ? DISPOSABLE_DOMAINS.has(m[1]) : false;\n}\n\nfunction isFakePhoneDigits(digits) {\n  const d = normalizeDigits(digits);\n  if (!d || d.length < 9) return true;\n  if (/^(\\d)\\1+$/.test(d)) return true;\n  if (d.includes('123456') || d.includes('00000')) return true;\n  return false;\n}\n\n// =================== Loosened Spam Decision (score-based) ===================\n\nfunction isSpamLead(parsed, mobileFormatted, phoneFormatted) {\n  const first = (parsed.firstName || '').trim();\n  const last = (parsed.lastName || '').trim();\n  const email = (parsed.email || '').trim();\n  const enquiry = (parsed.enquiry || '').trim();\n\n  const mobileDigits = normalizeDigits(mobileFormatted);\n  const phoneDigits = normalizeDigits(phoneFormatted);\n  const hasAnyPhone = mobileDigits.length > 0 || phoneDigits.length > 0;\n\n  let score = 0;\n\n  // Strong signals\n  if (hasBadNameWord(first, last)) score += 3;\n  if (email && isDisposableEmail(email)) score += 3;\n  if (isFakePhoneDigits(mobileDigits || phoneDigits)) score += 3;\n\n  // Medium signals\n  if (!hasAnyPhone) score += 2;\n  if (!email) score += 1;\n  if (!enquiry || enquiry.length < 8) score += 1;\n\n  // Name length (allow short real names)\n  if (first.length < 2) score += 2;\n  if (last.length < 2) score += 1;\n\n  // Only run gibberish detector on longer tokens\n  if (first.length >= 5 && isLikelyGibberishName(first)) score += 2;\n  if (last.length >= 5 && isLikelyGibberishName(last)) score += 2;\n\n  return score >= 4;\n}\n\n// =================== MAIN ===================\n\nreturn items.map(item => {\n  const json = item.json || {};\n  const rawText = json.text || json.textPlain || json.snippet || '';\n  const parsed = parseFormText(rawText);\n\n  // Normalize names (supports multi-word + full-name-in-one-field cases)\n  const name = splitFullName(parsed.firstName, parsed.lastName);\n  parsed.firstName = name.firstName;\n  parsed.lastName = name.lastName;\n\n  let mobileFormatted = '';\n  let phoneFormatted = '';\n\n  if (parsed.mobileRaw) {\n    mobileFormatted = formatAuPhone(parsed.mobileRaw, 'mobile');\n  }\n\n  if (parsed.phoneNumberRaw) {\n    const digits = normalizeDigits(parsed.phoneNumberRaw);\n    if (digits.startsWith('04')) {\n      mobileFormatted ||= formatAuPhone(parsed.phoneNumberRaw, 'mobile');\n    } else {\n      phoneFormatted = formatAuPhone(parsed.phoneNumberRaw, 'landline');\n    }\n  }\n\n  const leadQualifier = isSpamLead(parsed, mobileFormatted, phoneFormatted) ? 'Spam' : 'Good';\n\n  return {\n    json: {\n      Timestamp: getBrisbaneDate(json),\n      Id: json.id || '',\n      'Lead Type': 'Sliding Door Lead',\n      'First Name': parsed.firstName || '',\n      'Last Name': parsed.lastName || '',\n      'Mobile Number': mobileFormatted,\n      'Phone Number': phoneFormatted,\n      'Email Address': parsed.email || '',\n      Address: '',\n      State: parsed.state || '',\n      Suburb: parsed.suburb || '',\n      'Postal Code': '',\n      Enquiry: parsed.enquiry || '',\n      Quantity: parsed.quantity || '',\n\n      // IMPORTANT: use the exact key your schema expects (curly apostrophe)\n      \"Iâ€™d Like To Get My Project Underway\": cleanProjectTiming(parsed.projectTiming),\n\n      'How they heard about us': 'SDR Website',\n      'Lead Qualifier': leadQualifier,\n\n      // IMPORTANT: exact key casing for schema\n      referredBy: ''\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3280,
        -688
      ],
      "id": "0b2f7e89-e0a6-44da-8038-a468c7221cd7",
      "name": "SDR Parsing"
    },
    {
      "parameters": {
        "resource": "message",
        "guildId": {
          "__rl": true,
          "value": "753455160209965106",
          "mode": "list",
          "cachedResultName": "Window Revival",
          "cachedResultUrl": "https://discord.com/channels/753455160209965106"
        },
        "channelId": {
          "__rl": true,
          "value": "912496260823519232",
          "mode": "list",
          "cachedResultName": "leadsãƒ»new",
          "cachedResultUrl": "https://discord.com/channels/753455160209965106/912496260823519232"
        },
        "content": "===========\nLead Type: {{ $json['Lead Type'] }}\nTimestamp: {{ $json.Timestamp }}\nId: {{ $json.Id }}\nFirst Name: {{ $json['First Name'] }}\nLast Name: {{ $json['Last Name'] }}\nMobile Number: {{ $json['Mobile Number'] }}\nPhone Number: {{ $json['Phone Number'] }}\nEmail Address: {{ $json['Email Address'] }}\nAddress: {{ $json.Address }}\nState: {{ $json.State }}\nSuburb: {{ $json.Suburb }}\nPostal Code: {{ $json['Postal Code'] }}\nEnquiry: {{ $json.Enquiry }}\nQuantity: {{ $json.Quantity }}\nI'd Like To Get my Project Underway: {{ $json['Iâ€™d Like To Get My Project Underway'] }}\nHow they heard about us?: {{ $json['How they heard about us'] }}",
        "options": {}
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        4176,
        -128
      ],
      "id": "be7045d4-c862-419b-9d28-8f124713018d",
      "name": "Send a message",
      "webhookId": "3825e270-76f5-472d-ba19-ea9f542a60c8",
      "credentials": {
        "discordBotApi": {
          "id": "a0FDlWFh8PBA5Add",
          "name": "WR: Discord Bot Account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "messageId": "={{ $json.id }}"
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        4400,
        256
      ],
      "id": "0e874fe4-2c21-40ec-9712-63dc4230fced",
      "name": "Delete spam email",
      "webhookId": "de4c9c81-e1b4-446d-8230-0c15ed712c16",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "messageId": "={{ $json.Id }}"
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        3952,
        256
      ],
      "id": "412596bc-f04e-4215-89fc-974f18375037",
      "name": "Check id if exist before deleting",
      "webhookId": "2052dce9-a67d-47eb-8004-388bf3af2164",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        3952,
        -416
      ],
      "id": "9ac2169e-f789-43b8-88ca-ad6fdc087d24",
      "name": "Send to Wrapp",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  item.json.myNewField = 1;\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        4176,
        256
      ],
      "id": "97d142a3-74b4-45ec-8d43-eea863a3e07a",
      "name": "Get Ids"
    },
    {
      "parameters": {
        "amount": 10
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        3952,
        -224
      ],
      "id": "1d0630eb-0133-40a6-adf3-96d4ad94b73f",
      "name": "Wait",
      "webhookId": "c4924f00-19cd-4a7f-bbd7-18c5cdb1a70d"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -1664,
        -208
      ],
      "id": "58e39806-9b28-404e-b01a-e097bb52b3c2",
      "name": "Trigger every 5 minute"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -1440,
        -224
      ],
      "id": "de027805-4233-4889-bb49-f96b51b51e3b",
      "name": "Wait1",
      "webhookId": "2a72056d-7af1-47ed-a608-b34bb05075a3"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -768,
        -224
      ],
      "id": "1704f0a6-effa-4108-bd7e-edb8054a03b1",
      "name": "Wait2",
      "webhookId": "254ef1fd-13c3-4cf0-b858-53d35191ca63"
    },
    {
      "parameters": {
        "fieldToSplitOut": "id",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -992,
        -224
      ],
      "id": "65428fe0-0747-4525-bcb7-8da127e20727",
      "name": "Split Emails"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.labelIds || [] }}\n",
                    "rightValue": "Label_236316694232257385",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    },
                    "id": "853ec203-7401-4dd6-a636-9c3e2f143ce3"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "SDR"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "73d43b3e-4e0a-42e5-a797-65e5a4ca424f",
                    "leftValue": "={{ $json.labelIds || [] }}",
                    "rightValue": "Label_5972230113927178957",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "WR.net"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "dfdfd523-8675-4581-96b9-a2da47598c30",
                    "leftValue": "={{ $json.labelIds || [] }}",
                    "rightValue": "Label_4464659176251527724",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Facebook"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "b2a6c721-b36e-4492-ab27-200dd405c2da",
                    "leftValue": "={{ \n  $json.labelIds?.includes('Label_4746392800957065361') \n  && \n  $json.labelIds?.includes('Label_7577132244279306906') \n}}\n",
                    "rightValue": "3. Leads/3.8 Email Enquiry Gen",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Email Enquiry"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "38cee0bf-368d-41db-a96e-e03566c8ef72",
                    "leftValue": "={{ $json.labelIds || [] }}",
                    "rightValue": "Label_8054278402706687750",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Work Order/Quote Order"
            }
          ]
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        128,
        -272
      ],
      "id": "7ea1e50d-3167-4bac-bdc5-3addafdbb94d",
      "name": "Router"
    },
    {
      "parameters": {
        "operation": "get",
        "messageId": "={{ $json.id }}",
        "simple": false,
        "options": {
          "downloadAttachments": true
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [
        -544,
        -224
      ],
      "id": "2c3ff578-cac6-477b-9f27-e5700eb03034",
      "name": "Get a message",
      "webhookId": "ce396636-538a-46bb-aa54-5da8848c5e97",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e570add7-64c9-4339-b667-670a56ad8fa0",
              "leftValue": "={{ $json[\"labelIds\"].join(\",\") }}\n\n",
              "rightValue": "=Label_169",
              "operator": {
                "type": "string",
                "operation": "notContains"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -320,
        -224
      ],
      "id": "9df6c7b0-ac07-4840-9fe7-8c75e5f7719e",
      "name": "Ensure no label \"Label_169\" or Processed by n8n pass"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
              "name": "id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
              "name": "text",
              "value": "={{ $json.text }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3056,
        -688
      ],
      "id": "21d35ad8-37f5-406a-8f7b-c9b128f72102",
      "name": "Get Id and Text for SDR"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
              "name": "id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
              "name": "text",
              "value": "={{ $json.text }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3056,
        -496
      ],
      "id": "587ab281-b25f-438b-a3a3-a875afd4ac0d",
      "name": "Get Id and Text for Windowrevival.NET"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
              "name": "id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
              "name": "text",
              "value": "={{ $json.text }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3056,
        -304
      ],
      "id": "f629fa32-4851-4926-8a45-9d8962a8fa48",
      "name": "Get Id and Text for Facebook"
    },
    {
      "parameters": {
        "resource": "label",
        "limit": 10
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [
        -1440,
        -32
      ],
      "id": "dc716a58-baad-44f3-9bd6-a8d3e5628efc",
      "name": "Get many labels",
      "webhookId": "81da1f73-297d-4755-9c64-5df63073b9ac",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// This node \"freezes\" attachment metadata into JSON while keeping binary intact.\n// Router/other nodes sometimes drop binary; this reduces surprises and makes\n// downstream PDF filtering easier.\n\nreturn items.map(item => {\n  const bin = item.binary || {};\n  const attachments = Object.keys(bin).map(key => {\n    const b = bin[key] || {};\n    return {\n      key,                               // binary key like attachment_0\n      fileName: b.fileName || '',\n      mimeType: b.mimeType || '',\n      fileExtension: b.fileExtension || '',\n      fileSize: b.fileSize || 0,\n    };\n  });\n\n  item.json.attachments = attachments;\n  item.json.pdfAttachments = attachments.filter(a =>\n    (a.mimeType || '').toLowerCase() === 'application/pdf' ||\n    (a.fileExtension || '').toLowerCase() === 'pdf' ||\n    (a.fileName || '').toLowerCase().endsWith('.pdf')\n  );\n\n  item.json.pdfCount = item.json.pdfAttachments.length;\n\n  return item;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -96,
        -224
      ],
      "id": "71bee930-d747-405e-8d9e-06007c7f9bde",
      "name": "Preserve attachments"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "db6a1784-302c-49c1-a31d-cbec0d44128a",
              "leftValue": "={{ \n  Object.values($binary || {}).some(b => {\n    const mime = (b.mimeType || '').toLowerCase();\n    const name = (b.fileName || '').toLowerCase();\n    return mime === 'application/pdf' || mime.includes('pdf') || name.endsWith('.pdf');\n  })\n}}\n",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -1664,
        1440
      ],
      "id": "2da66561-af77-4ccc-bc0a-3a6997b92a10",
      "name": "Has PDF?",
      "disabled": true
    },
    {
      "parameters": {
        "fieldToSplitOut": "attachment",
        "include": "allOtherFields",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -1664,
        2112
      ],
      "id": "f3d08a0c-5f9c-4af0-835d-9ac1418f777a",
      "name": "Extract PDF text"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
              "name": "id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "dc93f011-914a-435f-a2b9-89a3781ad46f",
              "name": "threadId",
              "value": "={{ $json.threadId }}",
              "type": "string"
            },
            {
              "id": "6b5505e7-19ca-4065-b162-c9ce00799f7f",
              "name": "from",
              "value": "={{ $json.from?.value?.[0]?.address || $json.headers?.from || '' }}\n\n",
              "type": "string"
            },
            {
              "id": "738733ee-2ed9-4a25-997d-7d69288cae20",
              "name": "subject",
              "value": "={{ $json.subject || ($json.headers?.subject ?? '') }}\n",
              "type": "string"
            },
            {
              "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
              "name": "emailText",
              "value": "={{ $json.text || '' }}\n",
              "type": "string"
            },
            {
              "id": "35fd5361-ac87-471c-b521-02be618e69d5",
              "name": "emailHtml",
              "value": "={{ $json.textAsHtml || '' }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1664,
        1664
      ],
      "id": "422ae798-1507-430c-86b4-77f2f880d49a",
      "name": "Get email meta for WorkOrder/QuoteOrder",
      "disabled": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "015be041-8c3c-4249-885b-d693bc855db6",
              "name": "id",
              "value": "={{ $json.id }}\n",
              "type": "string"
            },
            {
              "id": "e055ef97-d725-4e83-9e92-a3dcc6b1f999",
              "name": "threadId",
              "value": "={{ $json.threadId }}\n",
              "type": "string"
            },
            {
              "id": "9f559eb6-2656-4aae-9367-4302b6530cb7",
              "name": "from",
              "value": "={{ $json.from?.value?.[0]?.address ?? $json.from ?? \"\" }}\n",
              "type": "string"
            },
            {
              "id": "8d11132e-6892-45ad-bf4c-2c5453e0b463",
              "name": "emailText",
              "value": "={{ $json.text ?? $json.snippet ?? \"\" }}\n",
              "type": "string"
            },
            {
              "id": "52bcb2fe-303f-4287-9d2c-bac0825e4488",
              "name": "emailHtml",
              "value": "={{ $json.html ?? \"\" }}",
              "type": "string"
            },
            {
              "id": "07b2ae01-0f69-43f8-b855-7b408a05d9f2",
              "name": "pdfText",
              "value": "\"\"",
              "type": "string"
            },
            {
              "id": "47557d74-734c-43db-8b2e-984a92676a00",
              "name": "pdfCount",
              "value": 0,
              "type": "number"
            },
            {
              "id": "44c2bdf3-77a6-4a03-bd94-1cb6aed07283",
              "name": "pdfFiles",
              "value": "[]",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1664,
        1888
      ],
      "id": "0d48cc61-2c41-475a-85df-88b480da5b01",
      "name": "No PDF"
    },
    {
      "parameters": {
        "jsCode": "function pickHeader(headers, name) {\n  if (!headers) return '';\n  if (Array.isArray(headers)) {\n    const h = headers.find(x => (x.name || '').toLowerCase() === name.toLowerCase());\n    return h?.value || '';\n  }\n  return headers[name] || headers[name.toLowerCase()] || headers[name.toUpperCase()] || '';\n}\n\nfunction isPdfFilename(name) {\n  return !!name && String(name).toLowerCase().endsWith('.pdf');\n}\n\n// âœ… Extract PDF URLs, href PDFs, and bare filenames (Workorder.pdf)\nfunction extractPdfLinks(text) {\n  if (!text) return [];\n  const t = String(text);\n  const out = new Set();\n\n  // 1) Real URLs ending .pdf\n  const urlMatches = t.match(/https?:\\/\\/[^\\s\"'<>]+\\.pdf\\b/gi);\n  if (urlMatches) urlMatches.forEach(u => out.add(u));\n\n  // 2) href=\"...pdf\" OR href=\\\"...pdf\\\"\n  const hrefPdfRe = /href\\s*=\\s*(?:\"|\\\\\")([^\"\\\\]+\\.pdf\\b)(?:\"|\\\\\")/gi;\n  let m;\n  while ((m = hrefPdfRe.exec(t)) !== null) {\n    const href = (m[1] || '').trim();\n    if (href) out.add(href);\n  }\n\n  // 3) Bare filename mentions (e.g., Workorder.pdf)\n  const fileMatches = t.match(/\\b[A-Za-z0-9][A-Za-z0-9 _-]{0,80}\\.pdf\\b/gi);\n  if (fileMatches) fileMatches.forEach(f => out.add(String(f).trim()));\n\n  return [...out];\n}\n\n// âœ… Extract ALL URLs (text + href + escaped href)\nfunction extractAllLinks(text) {\n  if (!text) return [];\n  const t = String(text);\n  const out = new Set();\n\n  // 1) Plain URLs in text\n  const urlRe = /https?:\\/\\/[^\\s\"'<>]+/gi;\n  const urls = t.match(urlRe);\n  if (urls) urls.forEach(u => out.add(u));\n\n  // 2) href=\"...\" links\n  const hrefRe = /href\\s*=\\s*[\"']([^\"']+)[\"']/gi;\n  let m;\n  while ((m = hrefRe.exec(t)) !== null) {\n    const href = (m[1] || '').trim();\n    if (href && /^https?:\\/\\//i.test(href)) out.add(href);\n  }\n\n  // 3) escaped href=\\\"...\\\"\n  const hrefEscapedRe = /href\\\\?=\\s*\\\\?\"([^\"\\\\]+)\\\\?\"/gi;\n  while ((m = hrefEscapedRe.exec(t)) !== null) {\n    const href = (m[1] || '').trim();\n    if (href && /^https?:\\/\\//i.test(href)) out.add(href);\n  }\n\n  return [...out];\n}\n\n// âœ… Pick the \"best\" PropertyTree workorder link (single)\nfunction pickWorkOrderUrl(links) {\n  if (!Array.isArray(links) || links.length === 0) return '';\n\n  // Strongest matches first\n  const priority = [\n    /agent\\.propertytree\\.com\\/external\\/api\\/workorder/i,\n    /\\/external\\/api\\/workorder/i,\n    /propertytree/i,\n    /workorder/i,\n  ];\n\n  for (const re of priority) {\n    const hit = links.find(l => re.test(l));\n    if (hit) return hit;\n  }\n\n  return links[0] || '';\n}\n\nfunction findPdfInBinary(binary) {\n  const results = [];\n  if (!binary || typeof binary !== 'object') return results;\n\n  for (const [key, b] of Object.entries(binary)) {\n    const fileName = b?.fileName || b?.file_name || '';\n    const mimeType = b?.mimeType || b?.mime_type || '';\n\n    const isPdf =\n      (mimeType && String(mimeType).toLowerCase() === 'application/pdf') ||\n      isPdfFilename(fileName);\n\n    if (isPdf) {\n      results.push({\n        source: 'binary',\n        binaryKey: key,\n        fileName,\n        mimeType: mimeType || 'application/pdf',\n        fileSize: b?.fileSize || b?.file_size || null,\n      });\n    }\n  }\n\n  return results;\n}\n\nfunction walkParts(parts, out = []) {\n  if (!Array.isArray(parts)) return out;\n  for (const p of parts) {\n    out.push(p);\n    if (p.parts) walkParts(p.parts, out);\n  }\n  return out;\n}\n\nfunction findPdfInPayload(payload) {\n  const results = [];\n  const partsFlat = walkParts(payload?.parts || []);\n\n  for (const p of partsFlat) {\n    const filename = p?.filename || '';\n    const mimeType = p?.mimeType || p?.mime_type || '';\n    const body = p?.body || {};\n    const attachmentId = body?.attachmentId || body?.attachment_id || null;\n\n    const isPdf =\n      (mimeType && String(mimeType).toLowerCase() === 'application/pdf') ||\n      isPdfFilename(filename);\n\n    if (isPdf && (filename || attachmentId)) {\n      results.push({\n        source: 'payload',\n        fileName: filename,\n        mimeType: mimeType || 'application/pdf',\n        attachmentId,\n        size: body?.size ?? null,\n      });\n    }\n  }\n\n  return results;\n}\n\nfunction normalizeFrom(fromRaw) {\n  let name = '';\n  let email = '';\n\n  if (fromRaw && typeof fromRaw === 'object' && Array.isArray(fromRaw.value) && fromRaw.value.length) {\n    const v = fromRaw.value[0] || {};\n    name = String(v.name || '').trim();\n    email = String(v.address || '').trim().toLowerCase();\n  } else {\n    const raw = String(fromRaw || '').trim();\n\n    const angle = raw.match(/<\\s*([^>]+@[^>\\s]+)\\s*>/);\n    if (angle) {\n      email = angle[1].trim().toLowerCase();\n      name = raw.replace(angle[0], '').replace(/\"/g, '').trim();\n    } else {\n      const em = raw.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n      if (em) {\n        email = em[0].trim().toLowerCase();\n        name = raw.replace(em[0], '').replace(/[<>\"()]/g, '').trim();\n      } else {\n        name = raw.replace(/\"/g, '').trim();\n      }\n    }\n  }\n\n  const parts = name.split(/\\s+/).filter(Boolean);\n  const firstName = parts[0] || '';\n  const lastName = parts.length > 1 ? parts.slice(1).join(' ') : '';\n\n  return {\n    senderEmail: email,\n    senderName: name,\n    senderFirstName: firstName,\n    senderLastName: lastName,\n  };\n}\n\nreturn items.map((item, idx) => {\n  const headers = item.json.headers || item.json.payload?.headers || null;\n\n  const subject = item.json.subject || pickHeader(headers, 'Subject');\n  const fromRaw = item.json.from || pickHeader(headers, 'From');\n  const to = item.json.to || pickHeader(headers, 'To');\n  const date = item.json.date || pickHeader(headers, 'Date');\n\n  const emailText =\n    item.json.body ||\n    item.json.textPlain ||\n    item.json.text ||\n    item.json.snippet ||\n    '';\n\n  const emailHtml =\n    item.json.html ||\n    item.json.textHtml ||\n    '';\n\n  const mergeKey =\n    item.json.id ||\n    item.json.messageId ||\n    pickHeader(headers, 'Message-Id') ||\n    `fallback_${idx}`;\n\n  const pdfFromBinary = findPdfInBinary(item.binary);\n  const pdfFromPayload = findPdfInPayload(item.json.payload);\n\n  const pdfAttachments = [...pdfFromBinary, ...pdfFromPayload];\n  const hasPdfAttachment = pdfAttachments.length > 0;\n\n  const combined = `${emailText} ${emailHtml}`;\n\n  // âœ… PDF links + filenames\n  const pdfLinks = extractPdfLinks(combined);\n  const hasPdfLinkOnly = pdfLinks.length > 0 && !hasPdfAttachment;\n\n  // âœ… ALL links (includes href + escaped href)\n  const allLinks = extractAllLinks(combined);\n\n  // âœ… best workorder url (single)\n  const workOrderUrl = pickWorkOrderUrl(allLinks);\n\n  // Sender\n  const sender = normalizeFrom(fromRaw);\n\n  return {\n    json: {\n      mergeKey,\n      mode: hasPdfAttachment\n        ? 'PROCESS_PDF'\n        : (hasPdfLinkOnly || workOrderUrl)\n          ? 'LINK_ONLY'\n          : 'READ_EMAIL_ONLY',\n\n      hasPdfAttachment,\n      hasPdfLinkOnly,\n      pdfAttachments,\n      pdfLinks,\n\n      emailMeta: {\n        id: item.json.id ?? '',\n        threadId: item.json.threadId ?? '',\n        text: item.json.text ?? item.json.textPlain ?? item.json.body ?? item.json.snippet ?? '',\n\n        senderEmail: sender.senderEmail,\n        senderFirstName: sender.senderFirstName,\n        senderLastName: sender.senderLastName,\n        senderName: sender.senderName,\n\n        subject,\n        //from: fromRaw,\n        //to,\n        date,\n        //snippet: item.json.snippet || '',\n        emailText,\n        //emailHtml,\n\n        // âœ… NEW\n        workOrderUrl,\n        //allLinks,\n      },\n    },\n    binary: item.binary,\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        576,
        240
      ],
      "id": "2658e38a-d7b5-47cc-87d3-731e7fc1d202",
      "name": "Build Email Meta"
    },
    {
      "parameters": {
        "jsCode": "const out = [];\n\nfunction hasPdf(bin) {\n  const b = bin || {};\n  return Object.values(b).some(x => {\n    const mime = (x.mimeType || '').toLowerCase();\n    const name = (x.fileName || '').toLowerCase();\n    return mime.includes('pdf') || name.endsWith('.pdf');\n  });\n}\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n\n  // If it has a PDF, SKIP\n  if (hasPdf(item.binary)) continue;\n\n  const meta = item.json.emailMeta || {};\n  const mergeKey = item.json.mergeKey || `fallback_${i}`;\n\n  out.push({\n    json: {\n      mergeKey,\n      emailMeta: meta,\n\n      // flat fields (so you SEE data in Table)\n      id: meta.id || '',\n      threadId: meta.threadId || '',\n      subject: meta.subject || '',\n      from: meta.from || '',\n      to: meta.to || '',\n      date: meta.date || '',\n      snippet: meta.snippet || '',\n      emailText: meta.emailText || '',\n      emailHtml: meta.emailHtml || '',\n\n      pdfCount: 0,\n      pdfFiles: [],\n      pdfText: '',\n    },\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1664,
        1216
      ],
      "id": "e9f994ca-cfb1-48a5-ba65-b8e218623086",
      "name": "Create NO-PDF list from Build Email Meta",
      "disabled": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a data extraction engine.\n\nYour task:\nExtract ONLY missing lead fields from the content below and return a SINGLE JSON OBJECT\nthat EXACTLY matches the required schema.\n\nâš ï¸ OUTPUT RULES (CRITICAL):\n- Output MUST be valid JSON only. No explanations, no markdown, no extra text.\n- ALL fields in the schema MUST be present.\n- If a value is unknown or not found, return an empty string \"\".\n- Do NOT remove, rename, or add fields.\n- Do NOT nest objects or arrays.\n\nHardcoded fields (DO NOT change these values):\n- Timestamp: {{ $json.Timestamp }}\n- Id: {{ $json.Id }}\n- Lead Type: {{ $json['Lead Type'] }}\n- First Name: {{ $json['First Name'] }}\n- Last Name: {{ $json['Last Name'] }}\n- Email Address: {{ $json['Email Address'] }}\n- How they heard about us: {{ $json['How they heard about us'] }}\n- Lead Qualifier: {{ $json['Lead Qualifier'] }}\n\n\nPhone rules:\n- Phone Number must belong to the requestor / agent / body corporate / tenant.\n- Ignore Window Revival phone numbers.\n\nAddress rules:\n- Address = unit + street only.\n- Suburb = locality only.\n- State = Australian abbreviation (e.g. QLD).\n- Postal Code:\n  - Use explicit 4-digit Australian postcode if shown.\n  - If missing but Suburb + State are known, you MAY populate the correct Australian postcode.\n  - Only output valid Australian postcodes.\n\nReferred By rule:\n- \"Referred By\" MUST be the company or organisation requesting the work.\n- Do NOT put a personâ€™s name here unless no company is mentioned.\n\nWork Order / Reference rules:\n- Identify any Work Order Number, Job Number, Quote Number, Reference ID, or Ticket ID.\n- INCLUDE this clearly inside Enquiry under **Invoice / Billing** as:\n  \"Reference / Work Order No: <value>\"\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nENQUIRY RULES â€“ VERY DETAILED SUMMARY\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nEnquiry MUST be a **clear, detailed, multi-line operational summary** built from:\n1) PDF Text (highest priority)\n2) EmailText\n3) Subject (lowest priority)\n\nThe goal:  \nðŸ“Œ A technician, scheduler, or accounts person should fully understand the job\nWITHOUT opening the email or PDF.\n\nFORMAT Enquiry EXACTLY like this (omit any line that has no data):\n\nJob Overview:\n- Job type: <inspection / quote / repair / work order>\n- Issue description: <what is wrong, symptoms, urgency if mentioned>\n- Affected items: <window / door type, location in unit if known>\n- Special notes: <constraints, expectations, deadlines>\n\nProperty Details:\n- Address: <unit + street>\n- Suburb / State / Postcode: <if available>\n- Property type: <unit / apartment / body corporate / commercial if stated>\n\nTenant / Access Information:\n- Tenant name: <if provided>\n- Tenant phone: <if provided>\n- Tenant email: <if provided>\n- Access instructions: <keys, times, contact-before-attending, etc.>\n- Site contact / agent: <name + company if stated>\n\nInvoice / Billing Instructions:\n- Bill to / Quote to: <company or entity>\n- ABN: <if present>\n- Email for invoices/quotes: <if present>\n- Reference / Work Order No: <job / quote / ticket number>\n- Approval required: <committee / manager / none if stated>\n\nKey Operational Details:\n- Required actions: <inspect, quote, repair, report>\n- Deliverables: <quote, photos, report, invoice>\n- Dates mentioned: <issued / due / preferred timeframe>\n- Any other critical instructions not captured above\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nINPUT DATA:\nSubject:\n{{ $json.Subject }}\n\nEmailText:\n{{ $json.EmailText }}\n\nPDF Text:\n{{ $json.pdfText }}\n\n---\n\nRETURN THIS EXACT JSON OBJECT, WITH THE SAME KEYS (INCLUDING THE CURLY APOSTROPHE IN Iâ€™d).\nONLY replace the empty strings \"\" with extracted values when found.\nDo NOT change the hardcoded values.\n\n{\n  \"Timestamp\": \"{{ $json.Timestamp }}\",\n  \"Id\": \"{{ $json.Id }}\",\n  \"Lead Type\": \"{{ $json['Lead Type'] }}\",\n  \"First Name\": \"{{ $json['First Name'] }}\",\n  \"Last Name\": \"{{ $json['Last Name'] }}\",\n  \"Mobile Number\": \"\",\n  \"Phone Number\": \"\",\n  \"Email Address\": \"{{ $json['Email Address'] }}\",\n  \"Address\": \"\",\n  \"State\": \"\",\n  \"Suburb\": \"\",\n  \"Postal Code\": \"\",\n  \"Enquiry\": \"\",\n  \"Quantity\": \"\",\n  \"Iâ€™d Like To Get My Project Underway\": \"\",\n  \"How they heard about us\": \"{{ $json['How they heard about us'] }}\",\n  \"Lead Qualifier\": \"{{ $json['Lead Qualifier'] }}\",\n  \"Referred By\": \"\"\n}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You are an AI assistant that extracts structured lead data from emails and PDF text.\nYou must return ONLY valid JSON.\nIf a field is missing, return an empty string.\nDo not guess.\nDo not explain.\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        2656,
        -80
      ],
      "id": "1a6de284-c015-40c1-9c75-158eeff023c2",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "responsesApiEnabled": false,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        2592,
        160
      ],
      "id": "873f4603-7fdf-4ef4-b29c-7fd231531d3b",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "oQQrCQWqdo1CuRzx",
          "name": "WRai: OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const SPLIT_NODE_NAME = \"Split PDFs (keep meta)\";\n\nconst splitItems = $items(SPLIT_NODE_NAME, 0);\nconst outMap = new Map();\n\nfor (let i = 0; i < items.length; i++) {\n  const extracted = items[i];\n  const meta = splitItems[i]?.json || {};\n\n  const mergeKey = meta.mergeKey;\n  if (!mergeKey) {\n    throw new Error(`Group PDFs: mergeKey missing at index ${i}. Check Split PDFs output.`);\n  }\n\n  if (!outMap.has(mergeKey)) {\n    outMap.set(mergeKey, {\n      json: {\n        mergeKey,\n        pdfCount: 0,\n        pdfFiles: [],\n        pdfText: \"\",\n      },\n    });\n  }\n\n  const agg = outMap.get(mergeKey).json;\n\n  agg.pdfCount += 1;\n  agg.pdfFiles.push({\n    key: meta.pdfKey || \"\",\n    fileName: meta.pdfFileName || \"\",\n    mimeType: meta.pdfMimeType || \"\",\n  });\n\n  const text =\n    extracted.json?.text ??\n    extracted.json?.data ??\n    extracted.json?.content ??\n    extracted.json?.extractedText ??\n    \"\";\n\n  if (String(text).trim()) {\n    agg.pdfText += (agg.pdfText ? \"\\n\\n---\\n\\n\" : \"\");\n    agg.pdfText += `### ${meta.pdfFileName || \"PDF\"}\\n${text}`;\n  }\n}\n\nreturn Array.from(outMap.values());\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1664,
        768
      ],
      "id": "271d4d98-8bbe-4f27-b08f-946cc6e1ca68",
      "name": "Group the PDF text",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  item.json.pdfText = item.json.pdfText || \"\";\n  item.json.pdfCount = item.json.pdfCount ?? 0;\n  item.json.pdfFiles = item.json.pdfFiles || [];\n  return item;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1664,
        992
      ],
      "id": "e2235883-c111-4a48-a3ce-0725ae3ae2bc",
      "name": "Normalize pdf fields",
      "disabled": true
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.Id }}",
        "contextWindowLength": "=5"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        2720,
        160
      ],
      "id": "92bc8184-c588-4cf7-a1b2-fbfed08b488b",
      "name": "Simple Memory"
    },
    {
      "parameters": {
        "operation": "getAll",
        "limit": 10,
        "filters": {
          "labelIds": [
            "Label_4464659176251527724"
          ]
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        -1216,
        64
      ],
      "id": "bda13613-66cf-4ab1-8d8f-1b93cd0e093e",
      "name": "Get Facebook Leads",
      "webhookId": "1227c9f0-3973-4cc4-86a8-6a876f1a0a59",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "limit": 10,
        "filters": {
          "labelIds": [
            "Label_236316694232257385"
          ]
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        -1216,
        -320
      ],
      "id": "f1af5aa8-2e91-4f45-b078-d9176dbf4e53",
      "name": "Get SDR Leads",
      "webhookId": "1227c9f0-3973-4cc4-86a8-6a876f1a0a59",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "limit": 10,
        "filters": {
          "labelIds": [
            "Label_5972230113927178957"
          ]
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        -1216,
        -128
      ],
      "id": "ec70a488-2dde-4efb-bb5b-b1defc1516b0",
      "name": "Get Winrev.net",
      "webhookId": "1227c9f0-3973-4cc4-86a8-6a876f1a0a59",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "operation": "getAll",
        "limit": 10,
        "filters": {
          "labelIds": [
            "Label_8054278402706687750"
          ]
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        -1216,
        256
      ],
      "id": "c8e49191-4b40-4e05-8883-35f3d6f0cd93",
      "name": "Get Email Work Order",
      "webhookId": "1227c9f0-3973-4cc4-86a8-6a876f1a0a59",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "ed3a503c-dacd-42cd-9ac0-ca8374a1da9a",
              "leftValue": "={{ $json.hasPdfAttachment }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            },
            {
              "id": "50c2da4e-d770-4f9d-b774-d905b3157327",
              "leftValue": "={{ $json.hasPdfLinkOnly }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        1024,
        240
      ],
      "id": "53d4534a-3c9d-426b-a4b3-a40ecc8d7f15",
      "name": "Check if there is PDF file"
    },
    {
      "parameters": {
        "jsCode": "// âœ… n8n Code node (Run Once for Each Item)\n// EMAIL-ONLY VERSION (no PDF processing)\n// - Parses AI output OR key:value text\n// - Forces Id from emailMeta/mergeKey if missing\n// - Always generates Brisbane Timestamp \"DD/MM/YYYY, HH:mm:ss\"\n// - Builds Enquiry from email meta + email body ONLY (no PDF sections)\n// - HARD-CODED business fields (Lead Type, How heard, Lead Qualifier)\n\nconst input = $input.item.json ?? {};\n\nconst fields = [\n  \"Timestamp\",\"Id\",\"Lead Type\",\"First Name\",\"Last Name\",\"Mobile Number\",\"Phone Number\",\n  \"Email Address\",\"Address\",\"State\",\"Suburb\",\"Postal Code\",\"Enquiry\",\"Quantity\",\n  \"Iâ€™d Like To Get My Project Underway\",\"How they heard about us\",\"Lead Qualifier\",\"Referred By\"\n];\n\nfunction deepCollectStrings(x, acc = []) {\n  if (x == null) return acc;\n  if (typeof x === \"string\") { const s = x.trim(); if (s) acc.push(s); return acc; }\n  if (Array.isArray(x)) { for (const v of x) deepCollectStrings(v, acc); return acc; }\n  if (typeof x === \"object\") {\n    const preferredKeys = [\"output_text\",\"text\",\"content\",\"message\",\"value\",\"delta\"];\n    for (const k of preferredKeys) if (k in x) deepCollectStrings(x[k], acc);\n    for (const k of Object.keys(x)) if (!preferredKeys.includes(k)) deepCollectStrings(x[k], acc);\n  }\n  return acc;\n}\n\nfunction stripFences(s){\n  return String(s||\"\")\n    .replace(/^```(?:json)?\\s*/i,\"\")\n    .replace(/```$/i,\"\")\n    .trim();\n}\n\nfunction tryParseJson(s){\n  s = stripFences(s); if (!s) return null;\n  try { return JSON.parse(s); } catch {}\n  const a=s.indexOf(\"{\"), b=s.lastIndexOf(\"}\");\n  if (a!==-1 && b!==-1 && b>a) { try { return JSON.parse(s.slice(a,b+1)); } catch {} }\n  const c=s.indexOf(\"[\"), d=s.lastIndexOf(\"]\");\n  if (c!==-1 && d!==-1 && d>c) { try { return JSON.parse(s.slice(c,d+1)); } catch {} }\n  return null;\n}\n\nfunction parseKeyValueLines(text){\n  const obj = {};\n  const lines = String(text||\"\").split(/\\r?\\n/).map(l=>l.trim()).filter(Boolean);\n  for (const line of lines) {\n    const m =\n      line.match(/^\\-?\\s*([^:]+?)\\s*:\\s*(.*)$/) ||\n      line.match(/^\\-?\\s*([^â€“-]+?)\\s*[â€“-]\\s*(.*)$/);\n    if (!m) continue;\n    obj[m[1].trim()] = (m[2]??\"\").trim();\n  }\n  return obj;\n}\n\n// ---------- Timestamp helper (Brisbane) ----------\nfunction brisbaneTimestampNow() {\n  const dtf = new Intl.DateTimeFormat(\"en-AU\", {\n    timeZone: \"Australia/Brisbane\",\n    day: \"2-digit\",\n    month: \"2-digit\",\n    year: \"numeric\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: false,\n  });\n\n  const parts = Object.fromEntries(dtf.formatToParts(new Date()).map(p => [p.type, p.value]));\n  return `${parts.day}/${parts.month}/${parts.year}, ${parts.hour}:${parts.minute}:${parts.second}`;\n}\n\nfunction looksLikeDesiredTimestampFormat(s) {\n  return /^\\d{2}\\/\\d{2}\\/\\d{4}, \\d{2}:\\d{2}:\\d{2}$/.test(String(s || \"\").trim());\n}\n\n// ---------- Enquiry formatting (EMAIL ONLY) ----------\nfunction normalizeNewlines(s) {\n  return String(s || \"\")\n    .replace(/\\r\\n/g, \"\\n\")\n    .replace(/\\r/g, \"\\n\")\n    .replace(/[ \\t]+\\n/g, \"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}\n\nfunction extractSection(text, label) {\n  const t = normalizeNewlines(text);\n  const re = new RegExp(`(^|\\\\n)${label}\\\\s*:\\\\s*`, \"i\");\n  const m = t.match(re);\n  if (!m) return null;\n\n  const startIdx = m.index + m[0].length;\n  const rest = t.slice(startIdx);\n  const stop = rest.search(/\\n(?:Email Subject|From|To|Email Body|Email HTML)\\s*:/i);\n  return (stop === -1 ? rest : rest.slice(0, stop)).trim();\n}\n\nfunction formatEnquiryEmailOnly(enquiryRaw, fallbackEmailMeta) {\n  let s = normalizeNewlines(enquiryRaw);\n\n  if (!s) {\n    const parts = [];\n    if (fallbackEmailMeta?.subject) parts.push(`Email Subject: ${fallbackEmailMeta.subject}`);\n    if (fallbackEmailMeta?.from) parts.push(`From: ${fallbackEmailMeta.from}`);\n    if (fallbackEmailMeta?.to) parts.push(`To: ${fallbackEmailMeta.to}`);\n    if (fallbackEmailMeta?.emailText) parts.push(`Email Body:\\n${fallbackEmailMeta.emailText}`);\n    s = parts.join(\"\\n\\n\");\n  }\n\n  return s;\n}\n\n// 1) Collect raw text\nconst raw = deepCollectStrings(input.output ?? input).join(\"\\n\\n\").trim();\n\n// 2) Parse AI output JSON first, else key/value lines\nlet parsed = tryParseJson(raw);\nif (Array.isArray(parsed)) parsed = parsed[0] ?? null;\nif (!parsed || typeof parsed !== \"object\") parsed = parseKeyValueLines(raw);\n\n// 3) Build output\nconst out = {};\nfor (const f of fields) out[f] = parsed?.[f] ?? \"\";\n\n// âœ… FORCE Id fallback\nconst idFallback =\n  input?.emailMeta?.id ||\n  input?.emailMeta?.threadId ||\n  input?.mergeKey ||\n  input?.id ||\n  input?.threadId ||\n  \"\";\n\nout[\"Id\"] = out[\"Id\"] || idFallback;\n\n// âœ… Timestamp (Brisbane)\nif (!out[\"Timestamp\"] || !looksLikeDesiredTimestampFormat(out[\"Timestamp\"])) {\n  out[\"Timestamp\"] = brisbaneTimestampNow();\n}\n\n// âœ… EMAIL-only Enquiry\nout[\"Enquiry\"] = formatEnquiryEmailOnly(\n  out[\"Enquiry\"],\n  input?.emailMeta || {}\n);\n\n// ================= HARD-CODED BUSINESS RULES =================\nout[\"Lead Type\"] = \"Work Order Lead\";\nout[\"How they heard about us\"] = \"Real Estate Property Managers\";\nout[\"Lead Qualifier\"] = \"Good\";\n// =============================================================\n\nreturn [{ json: out }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2368,
        432
      ],
      "id": "107dc6ef-d31b-40e5-8822-89bd58395967",
      "name": "Email only"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a data extraction engine.\n\nYour task:\nExtract ONLY missing lead fields and structured job details from the email below.\n\nHardcoded fields (DO NOT change these values):\n- Timestamp: {{ $json.Timestamp }}\n- Id: {{ $json.Id }}\n- Lead Type: {{ $json['Lead Type'] }}\n- How they heard about us: {{ $json['How they heard about us'] }}\n- Lead Qualifier: {{ $json['Lead Qualifier'] }}\n- Referred By: Real Estate Property Managers\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nCRITICAL CONTACT RULES (MANDATORY)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n- \"First Name\" and \"Last Name\" MUST be the EMAIL SENDER / REQUESTOR.\n- For \"Real Estate Property Managers\" leads:\n  - The sender is the PROPERTY MANAGER or AGENCY staff.\n  - Do NOT use tenant/resident name as the lead contact unless the tenant is explicitly the sender.\n- If the sender name is not clearly shown, leave First Name and Last Name blank.\n\nPHONE & EMAIL RULES\n- Phone numbers and email addresses MUST belong to the sender/requestor.\n- Do NOT use tenant, invoice, or third-party phone/email for lead contact fields.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nJOB & REFERENCE EXTRACTION RULES\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nExtract ONLY if explicitly present:\n- Work Order Number\n- Job Order Number\n- Quote Number\n- Reference Codes (e.g. \"T003\")\n- Job Description / Summary / Scope of Works\n- Key / Access notes\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nADDRESS RULES (STRICT)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n- Address = unit + street only.\n- Suburb = locality only.\n- State = Australian abbreviation (e.g. QLD).\n- Postal Code must be a valid Australian 4-digit postcode.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nENQUIRY RULES (VERY IMPORTANT)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n- Enquiry MUST contain line breaks using newline characters.\n- Do NOT write everything on one line.\n- Do NOT use bullet symbols (â€¢, -, *).\n- Use plain text with line breaks only.\n\nENQUIRY FORMAT (EXACT STRUCTURE):\nWork Order / Reference: <value or blank>\nProperty Address: <address, suburb state postcode>\nJob Description: <summary>\nKey / Access Notes: <if any>\n\nIf multiple references exist, choose the most relevant for \"Work Order / Reference\" and include others inside Job Description.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nOUTPUT FORMAT (STRICT JSON ONLY)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nReturn ONLY valid JSON.\nALL fields below MUST be present.\nIf a value is unknown or not found, return \"\".\nDo NOT rename fields.\nDo NOT add new fields.\nDo NOT nest objects.\nDo NOT include explanations, markdown, or commentary.\n\n{\n  \"Timestamp\": \"{{ $json.Timestamp }}\",\n  \"Id\": \"{{ $json.Id }}\",\n  \"Lead Type\": \"{{ $json['Lead Type'] }}\",\n  \"First Name\": \"\",\n  \"Last Name\": \"\",\n  \"Mobile Number\": \"\",\n  \"Phone Number\": \"\",\n  \"Email Address\": \"\",\n  \"Address\": \"\",\n  \"State\": \"\",\n  \"Suburb\": \"\",\n  \"Postal Code\": \"\",\n  \"Enquiry\": \"\",\n  \"Quantity\": \"\",\n  \"Iâ€™d Like To Get My Project Underway\": \"\",\n  \"How they heard about us\": \"{{ $json['How they heard about us'] }}\",\n  \"Lead Qualifier\": \"{{ $json['Lead Qualifier'] }}\",\n  \"Referred By\": \"Real Estate Property Managers\"\n}\n\nEmail body:\n{{ $json.Enquiry }}\n",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "You are an AI assistant that extracts structured lead data from emails and PDF text.\nYou must return ONLY valid JSON.\nIf a field is missing, return an empty string.\nDo not guess.\nDo not explain.\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        2656,
        432
      ],
      "id": "13d9ccee-5995-4466-a98a-9e49d4c92caa",
      "name": "AI Agent1"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-5-mini"
        },
        "responsesApiEnabled": false,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        2592,
        656
      ],
      "id": "16f1df29-c2c0-414e-a371-2865db006db7",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "oQQrCQWqdo1CuRzx",
          "name": "WRai: OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Email only').item.json.Id }}"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        2720,
        656
      ],
      "id": "abe30efd-2f31-4974-a054-7c14f04dcfd9",
      "name": "Simple Memory1"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"Timestamp\": \"string\",\n  \"Id\": \"string\",\n  \"Lead Type\": \"string\",\n  \"First Name\": \"string\",\n  \"Last Name\": \"string\",\n  \"Mobile Number\": \"string\",\n  \"Phone Number\": \"string\",\n  \"Email Address\": \"string\",\n  \"Address\": \"string\",\n  \"State\": \"string\",\n  \"Suburb\": \"string\",\n  \"Postal Code\": \"string\",\n  \"Enquiry\": \"string\",\n  \"Quantity\": \"string\",\n  \"Iâ€™d Like To Get My Project Underway\": \"string\",\n  \"How they heard about us\": \"string\",\n  \"Lead Qualifier\": \"string\",\n  \"Referred By\": \"string\"\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2848,
        656
      ],
      "id": "d9f4d98b-1f39-40c3-adae-3b34951974c1",
      "name": "Structured Output Parser"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "ba2e0e97-f6b8-4ac3-b647-c6f56ea7fff1",
              "name": "Timestamp",
              "value": "={{ $json.Timestamp }}",
              "type": "string"
            },
            {
              "id": "bcdad444-30ec-4813-aa97-d8b6f5116093",
              "name": "Id",
              "value": "={{ $json.Id }}",
              "type": "string"
            },
            {
              "id": "ff7cd238-b935-4ad2-989b-6ad1f8e6789f",
              "name": "Lead Type",
              "value": "={{ $json[\"Lead Type\"] }}",
              "type": "string"
            },
            {
              "id": "57bc231d-9a83-4236-8a70-6d7ea8149127",
              "name": "First Name",
              "value": "={{ $json[\"First Name\"] }}",
              "type": "string"
            },
            {
              "id": "fc8c49e6-6095-411a-9bb4-5579f3eb4887",
              "name": "Last Name",
              "value": "={{ $json[\"Last Name\"] }}",
              "type": "string"
            },
            {
              "id": "deb663a6-0bfb-4896-9f92-723a3295cfb4",
              "name": "Mobile Number",
              "value": "={{ $json[\"Mobile Number\"] }}",
              "type": "string"
            },
            {
              "id": "bdc6140e-39b3-4b44-82a1-fa42ae81ba12",
              "name": "Phone Number",
              "value": "={{ $json[\"Phone Number\"] }}",
              "type": "string"
            },
            {
              "id": "a166fbe7-eb6b-479f-a8b6-38189205c385",
              "name": "Email Address",
              "value": "={{ $json[\"Email Address\"] }}",
              "type": "string"
            },
            {
              "id": "03cf1ca4-f1e1-4d60-9e7d-0d6ed61c8990",
              "name": "Address",
              "value": "={{ $json.Address }}",
              "type": "string"
            },
            {
              "id": "dc4fc907-f341-4443-8c41-0707f8460a93",
              "name": "State",
              "value": "={{ $json.State }}",
              "type": "string"
            },
            {
              "id": "057479b5-8277-4e6f-ae45-fcad076c0ec1",
              "name": "Suburb",
              "value": "={{ $json.Suburb }}",
              "type": "string"
            },
            {
              "id": "4add8b77-b6cb-4f50-a2ba-d82b0941b359",
              "name": "Postal Code",
              "value": "={{ $json[\"Postal Code\"] }}",
              "type": "string"
            },
            {
              "id": "1722ba2a-4b20-4ff8-82a3-307f934c5da2",
              "name": "Enquiry",
              "value": "={{ $json.Enquiry }}",
              "type": "string"
            },
            {
              "id": "ff3b995b-4fca-48c6-bd74-925d888bc8ab",
              "name": "Quantity",
              "value": "={{ $json.Quantity }}",
              "type": "string"
            },
            {
              "id": "56626fe5-134f-4267-8ca0-ec2db595dd7b",
              "name": "Enquiry",
              "value": "={{ $json.Enquiry }}",
              "type": "string"
            },
            {
              "id": "3bba2c17-3b8c-408b-9166-a045b21ef5aa",
              "name": "Quantity",
              "value": "={{ $json.Quantity }}",
              "type": "string"
            },
            {
              "id": "5fdbf2f9-ab3a-4435-8ead-a59a066dcd4b",
              "name": "Iâ€™d Like To Get My Project Underway",
              "value": "={{ $json[\"Iâ€™d Like To Get My Project Underway\"] }}",
              "type": "string"
            },
            {
              "id": "c242e54b-98ed-4384-9dff-0012f078c6ef",
              "name": "How they heard about us",
              "value": "={{ $json[\"How they heard about us\"] }}",
              "type": "string"
            },
            {
              "id": "1f66b97f-eb27-4785-8231-f4f8c3b37a1c",
              "name": "Lead Qualifier",
              "value": "={{ $json[\"Lead Qualifier\"] }}",
              "type": "string"
            },
            {
              "id": "b0afdf1f-b43a-4975-b873-18e452de253d",
              "name": "Referred By",
              "value": "={{ $json[\"Referred By\"] }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        3280,
        240
      ],
      "id": "7be45353-3120-45a2-8251-0cac1531169d",
      "name": "Work Order Set Fields"
    },
    {
      "parameters": {
        "jsCode": "function toMs(d) {\n  const t = Date.parse(d);\n  return Number.isFinite(t) ? t : Number.POSITIVE_INFINITY;\n}\n\nconst bestByThread = new Map();\n\nfor (const item of items) {\n  const threadId = item.json?.emailMeta?.threadId || item.json?.threadId || item.json?.mergeKey || 'no_thread';\n  const ms = toMs(item.json?.emailMeta?.date);\n\n  const prev = bestByThread.get(threadId);\n  if (!prev) {\n    bestByThread.set(threadId, { item, ms });\n    continue;\n  }\n\n  // âœ… Keep the OLDEST message (origin)\n  if (ms < prev.ms) {\n    bestByThread.set(threadId, { item, ms });\n  }\n}\n\n// Return only origins (one item per thread)\nreturn Array.from(bestByThread.values()).map(x => x.item);\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        240
      ],
      "id": "46e42b82-b50f-465f-87fd-ec43eaa1048c",
      "name": "filters to origin per thread"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"Timestamp\": \"string\",\n  \"Id\": \"string\",\n  \"Lead Type\": \"string\",\n  \"First Name\": \"string\",\n  \"Last Name\": \"string\",\n  \"Mobile Number\": \"string\",\n  \"Phone Number\": \"string\",\n  \"Email Address\": \"string\",\n  \"Address\": \"string\",\n  \"State\": \"string\",\n  \"Suburb\": \"string\",\n  \"Postal Code\": \"string\",\n  \"Enquiry\": \"string\",\n  \"Quantity\": \"string\",\n  \"Iâ€™d Like To Get My Project Underway\": \"string\",\n  \"How they heard about us\": \"string\",\n  \"Lead Qualifier\": \"string\",\n  \"Referred By\": \"string\"\n}\n"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        2848,
        160
      ],
      "id": "e759ec12-4d36-4cab-9578-e3d69ddd4b1f",
      "name": "Structured Output Parser1"
    },
    {
      "parameters": {
        "operation": "getAll",
        "limit": 10,
        "filters": {
          "labelIds": []
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        -1216,
        -512
      ],
      "id": "8134cd75-6412-482a-9a5c-21441549d4fe",
      "name": "Get Emails",
      "webhookId": "1227c9f0-3973-4cc4-86a8-6a876f1a0a59",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      }
    },
    {
      "parameters": {
        "operation": "rowNotExists",
        "dataTableId": {
          "__rl": true,
          "value": "xP2ggRHskNpdbivo",
          "mode": "list",
          "cachedResultName": "email_threads",
          "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
        },
        "filters": {
          "conditions": [
            {
              "keyName": "threadId",
              "keyValue": "={{ $json.threadId }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        2720,
        -688
      ],
      "id": "2c3a6c9c-cbcb-4590-9e94-870e77b06962",
      "name": "SDR - Check if threadId is exists otherwise create"
    },
    {
      "parameters": {
        "operation": "rowNotExists",
        "dataTableId": {
          "__rl": true,
          "value": "xP2ggRHskNpdbivo",
          "mode": "list",
          "cachedResultName": "email_threads",
          "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
        },
        "filters": {
          "conditions": [
            {
              "keyName": "threadId",
              "keyValue": "={{ $json.threadId }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        2720,
        -304
      ],
      "id": "19154eae-8007-4dfc-bd38-eabcb167b6aa",
      "name": "FB - Check if threadId is exists otherwise create"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "xP2ggRHskNpdbivo",
          "mode": "list",
          "cachedResultName": "email_threads",
          "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "threadId": "={{ $json.Id }}"
          },
          "matchingColumns": [
            "threadId"
          ],
          "schema": [
            {
              "id": "threadId",
              "displayName": "threadId",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        4176,
        64
      ],
      "id": "ba76aa92-5d1d-4c5f-bdb2-b33f8d2c6610",
      "name": "Insert row for ThreadId"
    },
    {
      "parameters": {
        "operation": "rowNotExists",
        "dataTableId": {
          "__rl": true,
          "value": "xP2ggRHskNpdbivo",
          "mode": "list",
          "cachedResultName": "email_threads",
          "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
        },
        "filters": {
          "conditions": [
            {
              "keyName": "threadId",
              "keyValue": "={{ $json.threadId }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        2720,
        -496
      ],
      "id": "2ce30bb9-2418-41a5-a65d-b2a8230a3088",
      "name": "WRnet - Check if threadId is exists otherwise create1"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.hasPdfAttachment }}",
                    "rightValue": false,
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "e2336aaa-155d-4b4b-ab79-1fad0bbef319"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "PDF"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "4e1a9157-1cfc-421d-94a1-c9ea9c852225",
                    "leftValue": "={{ $json.hasPdfLinkOnly }}",
                    "rightValue": false,
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Link"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        1248,
        32
      ],
      "id": "122ef472-6f09-4e48-8540-45796ea74372",
      "name": "Switch"
    },
    {
      "parameters": {
        "url": "={{ $json.emailMeta.workOrderUrl }}",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [
        1696,
        160
      ],
      "id": "d06d1449-3134-421f-b7a6-335b867d82f7",
      "name": "Download PDF file from Link"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        1920,
        160
      ],
      "id": "5fe5e8f7-1e21-4020-a698-9f9b5b3b9bb6",
      "name": "HTTP Request â†’ Read Binary File â†’ Extract Text"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        1920,
        -64
      ],
      "id": "6b197a5f-e7a9-46af-aadf-331cb3eea0f1",
      "name": "PDF File â†’ Extract Text"
    },
    {
      "parameters": {
        "jsCode": "const out = [];\n\nfor (const item of items) {\n  const mergeKey = item.json.mergeKey;\n\n  if (!mergeKey) {\n    throw new Error(\n      \"Split PDFs: mergeKey missing. Ensure this node receives output from 'Build Email Meta' and no node in between overwrites json.\"\n    );\n  }\n\n  // 1) Handle binary PDFs (attachments)\n  const bin = item.binary || {};\n  for (const key of Object.keys(bin)) {\n    const b = bin[key];\n    if (!b) continue;\n\n    const fileName = (b.fileName || \"\").toLowerCase();\n    const mime = (b.mimeType || \"\").toLowerCase();\n    const isPdf =\n      mime === \"application/pdf\" || mime.includes(\"pdf\") || fileName.endsWith(\".pdf\");\n    if (!isPdf) continue;\n\n    out.push({\n      json: {\n        // keep meta\n        mergeKey,\n        emailMeta: item.json.emailMeta,\n        mode: item.json.mode,\n\n        // pdf meta\n        source: \"binary\",\n        pdfKey: key,\n        pdfFileName: b.fileName || \"\",\n        pdfMimeType: b.mimeType || \"\",\n      },\n      binary: {\n        data: b,\n      },\n    });\n  }\n\n  // 2) Handle LINK_ONLY PDFs (no binary present)\n  const pdfLinks = Array.isArray(item.json.pdfLinks) ? item.json.pdfLinks : [];\n  const workOrderUrl = item.json.emailMeta?.workOrderUrl || item.json.workOrderUrl || \"\";\n\n  for (const name of pdfLinks) {\n    // If the email provides a real URL to download (workOrderUrl), carry it forward\n    // so the next node (HTTP Request) can download the PDF.\n    out.push({\n      json: {\n        mergeKey,\n        emailMeta: item.json.emailMeta,\n        mode: item.json.mode,\n\n        source: \"link_only\",\n        pdfFileName: name || \"\",\n        pdfUrl: workOrderUrl, // <- this is the important bit for downstream download\n      },\n    });\n  }\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1472,
        160
      ],
      "id": "b250c5e0-59fb-4f5b-92ba-2ecc47206378",
      "name": "Link with metadata preserved"
    },
    {
      "parameters": {
        "jsCode": "// âœ… Code node\n// Pull emailMeta from: $('Link with metadata preserved').first().json.emailMeta\n// Use senderName for First / Last Name\n// Use senderEmail for Email Address\n// Add Brisbane Timestamp\n// pdfText comes from: $input.first().json.text\n// Preserve binary\n\nconst em = $('Link with metadata preserved').first()?.json?.emailMeta || {};\n\n// ---------- Brisbane timestamp helper ----------\nfunction brisbaneTimestampNow() {\n  const dtf = new Intl.DateTimeFormat('en-AU', {\n    timeZone: 'Australia/Brisbane',\n    day: '2-digit',\n    month: '2-digit',\n    year: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n\n  const parts = Object.fromEntries(\n    dtf.formatToParts(new Date()).map(p => [p.type, p.value])\n  );\n\n  return `${parts.day}/${parts.month}/${parts.year}, ${parts.hour}:${parts.minute}:${parts.second}`;\n}\n\n// ---------- Split senderName ----------\nfunction splitName(name) {\n  if (!name || typeof name !== 'string') {\n    return { firstName: '', lastName: '' };\n  }\n\n  const parts = name.trim().split(/\\s+/);\n  return {\n    firstName: parts[0] || '',\n    lastName: parts.slice(1).join(' ') || ''\n  };\n}\n\nconst nameParts = splitName(em.senderName);\nconst senderEmail = em.senderEmail ?? '';\n\n// âœ… pdf text shared across all items\nconst pdfText = $input.first()?.json?.text ?? '';\n\nreturn items.map(item => ({\n  json: {\n    // âœ… Timestamp\n    Timestamp: brisbaneTimestampNow(),\n\n    // âœ… Email basics\n    Id: em.id ?? '',\n    Subject: em.subject ?? '',\n    EmailText: em.emailText ?? (em.text ?? ''),\n\n    // âœ… Sender â†’ Lead identity\n    'First Name': nameParts.firstName,\n    'Last Name': nameParts.lastName,\n    'Email Address': senderEmail,\n\n    // âœ… Hard-coded lead fields\n    'Lead Type': 'Work Order Lead',\n    'How they heard about us': 'Real Estate Property Managers',\n    'Lead Qualifier': 'Good',\n\n    // âœ… PDF text (from OCR / extraction node)\n    pdfText\n  },\n\n  // âœ… Preserve binary\n  binary: item.binary\n}));\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2144,
        160
      ],
      "id": "2f1ac898-8ec2-445b-8cda-9dffe59ab829",
      "name": "Merge Link data and email Meta"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "a03a6e96-2e87-4b93-97d9-c960604be4bf",
              "name": "Timestamp",
              "value": "={{ $json.Timestamp }}",
              "type": "string"
            },
            {
              "id": "c8705047-a421-45e6-96a8-63e0b0c90587",
              "name": "Id",
              "value": "={{ $json.Id }}",
              "type": "string"
            },
            {
              "id": "0da2dd82-fdbf-4e91-b9ad-a54177815b16",
              "name": "Lead Type",
              "value": "={{ $json[\"Lead Type\"] }}",
              "type": "string"
            },
            {
              "id": "90923e2d-7523-40a7-b0e4-a75963e75a4a",
              "name": "First Name",
              "value": "={{ $json['First Name'] }}",
              "type": "string"
            },
            {
              "id": "3d3bf238-8488-4738-8a79-53f59c4c2a63",
              "name": "Last Name",
              "value": "={{ $json['Last Name'] }}",
              "type": "string"
            },
            {
              "id": "53e843da-387b-4508-9b67-037455dcfdfc",
              "name": "Email Address",
              "value": "={{ $json[\"Email Address\"] }}",
              "type": "string"
            },
            {
              "id": "dc41282e-d74c-4463-8cf0-ae449a564717",
              "name": "How they heard about us",
              "value": "={{ $json[\"How they heard about us\"] }}",
              "type": "string"
            },
            {
              "id": "097ebaca-c780-419a-b8c7-09c3c8a171ab",
              "name": "Lead Qualifier",
              "value": "={{ $json[\"Lead Qualifier\"] }}",
              "type": "string"
            },
            {
              "id": "93ad8908-b286-4858-bb30-27d42ff26213",
              "name": "Subject",
              "value": "={{ $json.Subject }}",
              "type": "string"
            },
            {
              "id": "0b42f440-fc55-4030-af8e-2311c47f9968",
              "name": "EmailText",
              "value": "={{ $json.EmailText }}",
              "type": "string"
            },
            {
              "id": "1c7b69a6-ff4c-42d2-b842-c8c4fee8fb25",
              "name": "pdfText",
              "value": "={{ $json.pdfText }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2368,
        32
      ],
      "id": "a0b56f43-92fa-47ec-b005-b71c8c675eea",
      "name": "Set Work Order Fields"
    },
    {
      "parameters": {
        "jsCode": "const out = [];\n\nfor (const item of items) {\n  const j = item.json || {};\n  const mergeKey = j.mergeKey;\n\n  if (!mergeKey) {\n    throw new Error(\n      \"Split PDFs: mergeKey missing. Ensure this node receives output from 'Build Email Meta' and no node in between overwrites json.\"\n    );\n  }\n\n  const emailMeta = { ...(j.emailMeta || {}) };\n  delete emailMeta.workOrderUrl;\n\n  const bin = item.binary || {};\n  const keys = Object.keys(bin);\n\n  for (const key of keys) {\n    const b = bin[key];\n    if (!b) continue;\n\n    const fileName = (b.fileName || \"\").toLowerCase();\n    const mime = (b.mimeType || \"\").toLowerCase();\n    const isPdf =\n      mime === \"application/pdf\" ||\n      mime.includes(\"pdf\") ||\n      fileName.endsWith(\".pdf\");\n\n    if (!isPdf) continue;\n\n    out.push({\n      json: {\n        mergeKey,\n        emailMeta,\n        pdfKey: key,\n        pdfFileName: b.fileName || \"\",\n        pdfMimeType: b.mimeType || \"\",\n      },\n      binary: {\n        // âœ… only one binary key so it won't duplicate\n        data: b,\n      },\n    });\n  }\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1696,
        -64
      ],
      "id": "1a6e9295-7081-422f-a66f-122ca67349cd",
      "name": "PDF attached with metadata preserved"
    },
    {
      "parameters": {
        "jsCode": "// ONE STEP after Extract Text:\n// - Extract Text output: item.json.text\n// - Original meta from: $('PDF attached with metadata preserved').all()[i].json.emailMeta\n// Output: flat fields + PDFText + Lead fields + Brisbane Timestamp\n// Removes: ThreadId, EmailDate\n\nfunction brisbaneTimestampNow() {\n  const dtf = new Intl.DateTimeFormat('en-AU', {\n    timeZone: 'Australia/Brisbane',\n    day: '2-digit',\n    month: '2-digit',\n    year: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n\n  const parts = Object.fromEntries(\n    dtf.formatToParts(new Date()).map(p => [p.type, p.value])\n  );\n\n  // Example format: 10/02/2026, 10:46:25\n  return `${parts.day}/${parts.month}/${parts.year}, ${parts.hour}:${parts.minute}:${parts.second}`;\n}\n\nconst originals = $('PDF attached with metadata preserved').all();\n\nif (originals.length !== items.length) {\n  throw new Error(`Count mismatch: originals=${originals.length} extracted=${items.length}`);\n}\n\nreturn items.map((extractedItem, i) => {\n  const ex = extractedItem.json || {};\n  const orig = originals[i].json || {};\n  const em = orig.emailMeta || {};\n\n  return {\n    json: {\n      // âœ… Timestamp (Brisbane)\n      Timestamp: brisbaneTimestampNow(),\n\n      // âœ… Exploded email fields\n      Id: em.id ?? '',\n      Subject: em.subject ?? '',\n      //SenderName: em.senderName ?? '',\n      'First Name': em.senderFirstName ?? '',\n      'Last Name': em.senderLastName ?? '',\n      'Email Address': em.senderEmail ?? '',\n      EmailText: em.emailText ?? em.text ?? '',\n\n      // âœ… PDF text from Extract Text node\n      pdfText: ex.text ?? '',\n\n      // âœ… Lead fields\n      'Lead Qualifier': 'Good',\n      'How they heard about us': 'Real Estate Property Managers',\n      'Lead Type': 'Work Order Lead',\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2144,
        -64
      ],
      "id": "43a2d2e1-5d50-49ef-aced-6dcd65a2a17a",
      "name": "Merge PDF and Email Meta"
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output ?? item.json\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3056,
        32
      ],
      "id": "7cf67082-ee50-4c21-9f65-662957ee3f6c",
      "name": "PDF Unwrapped Output "
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output ?? item.json\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3056,
        432
      ],
      "id": "e3761740-da03-4615-a09f-9efbcd74cc77",
      "name": "Email Unwrapped Output"
    },
    {
      "parameters": {
        "operation": "rowNotExists",
        "dataTableId": {
          "__rl": true,
          "value": "xP2ggRHskNpdbivo",
          "mode": "list",
          "cachedResultName": "email_threads",
          "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
        },
        "filters": {
          "conditions": [
            {
              "keyName": "threadId",
              "keyValue": "={{ $json.threadId }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        352,
        240
      ],
      "id": "b07361ba-7857-484f-9bb4-30908b6f838c",
      "name": "Work Order - Check if threadId is exists otherwise create1"
    },
    {
      "parameters": {
        "operation": "rowNotExists",
        "dataTableId": {
          "__rl": true,
          "value": "xP2ggRHskNpdbivo",
          "mode": "list",
          "cachedResultName": "email_threads",
          "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
        },
        "filters": {
          "conditions": [
            {
              "keyName": "threadId",
              "keyValue": "={{ $json.threadId }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1.1,
      "position": [
        352,
        -160
      ],
      "id": "c5986479-3320-469b-994b-0fd168b7347a",
      "name": "Work Order - Check if threadId is exists otherwise create"
    },
    {
      "parameters": {
        "jsCode": "// Code node (Run once for each item)\n// Creates: Timestamp (Brisbane), Id, Subject, EmailText, First Name, Last Name, Email Address\n// Tries multiple common paths for fields from Gmail/IMAP outputs.\n\nfunction brisbaneTimestampNow() {\n  const dtf = new Intl.DateTimeFormat('en-AU', {\n    timeZone: 'Australia/Brisbane',\n    day: '2-digit',\n    month: '2-digit',\n    year: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n\n  const parts = Object.fromEntries(\n    dtf.formatToParts(new Date()).map(p => [p.type, p.value])\n  );\n\n  // e.g. 10/02/2026, 10:46:25\n  return `${parts.day}/${parts.month}/${parts.year}, ${parts.hour}:${parts.minute}:${parts.second}`;\n}\n\nfunction parseFromField(fromVal) {\n  if (!fromVal) return { firstName: '', lastName: '', email: '' };\n\n  let text = '';\n  if (typeof fromVal === 'string') text = fromVal;\n  else if (typeof fromVal === 'object') text = fromVal.text || fromVal.value || '';\n\n  // \"Name Here\" <email@domain.com>\n  const match = text.match(/\"?([^\"<]+?)\"?\\s*<([^>]+)>/);\n  if (match) {\n    const name = match[1].trim();\n    const email = match[2].trim();\n    const parts = name.split(/\\s+/);\n    return {\n      firstName: parts[0] || '',\n      lastName: parts.slice(1).join(' ') || '',\n      email,\n    };\n  }\n\n  // email only\n  const emailOnly = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n  return { firstName: '', lastName: '', email: emailOnly ? emailOnly[0] : '' };\n}\n\nreturn items.map(item => {\n  const j = item.json || {};\n\n  // Try common locations for fields\n  const id =\n    j.id ??\n    j.messageId ??\n    j.message?.id ??\n    j.emailMeta?.id ??\n    '';\n\n  const subject =\n    j.subject ??\n    j.Subject ??\n    j.emailMeta?.subject ??\n    '';\n\n  const emailText =\n    j.text ??\n    j.EmailText ??\n    j.emailText ??\n    j.snippet ??\n    j.body ??\n    j.emailMeta?.text ??\n    j.emailMeta?.emailText ??\n    '';\n\n  // \"from\" can be string or object depending on node\n  const fromRaw =\n    j.from ??\n    j.From ??\n    j.sender ??\n    j.senderEmail ?? // sometimes only email\n    j.emailMeta?.from ??\n    j.emailMeta?.senderEmail ??\n    '';\n\n  // If we only have senderEmail but also have senderName, build a proper From string\n  const senderName = j.senderName ?? j.emailMeta?.senderName ?? '';\n  const senderEmail = j.senderEmail ?? j.emailMeta?.senderEmail ?? '';\n  const effectiveFrom =\n    (senderName && senderEmail) ? `${senderName} <${senderEmail}>` : fromRaw;\n\n  const parsedFrom = parseFromField(effectiveFrom);\n\n  return {\n    json: {\n      Timestamp: brisbaneTimestampNow(),\n      Id: String(id),\n      Subject: String(subject),\n      EmailText: String(emailText),\n\n      'First Name': parsedFrom.firstName,\n      'Last Name': parsedFrom.lastName,\n      'Email Address': parsedFrom.email || senderEmail || '',\n    },\n    binary: item.binary,\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        576,
        -160
      ],
      "id": "3059c0d1-ed8d-47f3-8d35-b2b0ea640864",
      "name": "Email only1"
    },
    {
      "parameters": {
        "site": {
          "__rl": true,
          "mode": "list",
          "value": ""
        },
        "requestOptions": {}
      },
      "type": "n8n-nodes-base.microsoftSharePointTool",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "eddd7dfe-67cf-4e0b-8d20-1f738be34278",
      "name": "Download file in Microsoft SharePoint"
    }
  ],
  "connections": {
    "Append row in sheet": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Send to Wrapp",
            "type": "main",
            "index": 0
          },
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check id if exist before deleting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FB Parsing": {
      "main": [
        [
          {
            "node": "Append row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Windowrevival.NET Parsing": {
      "main": [
        [
          {
            "node": "Append row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SDR Parsing": {
      "main": [
        [
          {
            "node": "Append row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete spam email": {
      "main": [
        []
      ]
    },
    "Check id if exist before deleting": {
      "main": [
        [
          {
            "node": "Get Ids",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Ids": {
      "main": [
        [
          {
            "node": "Delete spam email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send a message": {
      "main": [
        []
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Send a message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Add label to message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Insert row for ThreadId",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger every 5 minute": {
      "main": [
        [
          {
            "node": "Wait1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get many labels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait1": {
      "main": [
        [
          {
            "node": "Get Facebook Leads",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get SDR Leads",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Winrev.net",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Email Work Order",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait2": {
      "main": [
        [
          {
            "node": "Get a message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Emails": {
      "main": [
        [
          {
            "node": "Wait2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get a message": {
      "main": [
        [
          {
            "node": "Ensure no label \"Label_169\" or Processed by n8n pass",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure no label \"Label_169\" or Processed by n8n pass": {
      "main": [
        [
          {
            "node": "Preserve attachments",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Router": {
      "main": [
        [
          {
            "node": "SDR - Check if threadId is exists otherwise create",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "WRnet - Check if threadId is exists otherwise create1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "FB - Check if threadId is exists otherwise create",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Work Order - Check if threadId is exists otherwise create",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Work Order - Check if threadId is exists otherwise create1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Id and Text for SDR": {
      "main": [
        [
          {
            "node": "SDR Parsing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Id and Text for Windowrevival.NET": {
      "main": [
        [
          {
            "node": "Windowrevival.NET Parsing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Id and Text for Facebook": {
      "main": [
        [
          {
            "node": "FB Parsing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preserve attachments": {
      "main": [
        [
          {
            "node": "Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has PDF?": {
      "main": [
        [],
        []
      ]
    },
    "Extract PDF text": {
      "main": [
        []
      ]
    },
    "Get email meta for WorkOrder/QuoteOrder": {
      "main": [
        []
      ]
    },
    "No PDF": {
      "main": [
        []
      ]
    },
    "Build Email Meta": {
      "main": [
        [
          {
            "node": "filters to origin per thread",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create NO-PDF list from Build Email Meta": {
      "main": [
        []
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "PDF Unwrapped Output ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Group the PDF text": {
      "main": [
        []
      ]
    },
    "Normalize pdf fields": {
      "main": [
        []
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Get Facebook Leads": {
      "main": [
        [
          {
            "node": "Split Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get SDR Leads": {
      "main": [
        [
          {
            "node": "Split Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Winrev.net": {
      "main": [
        [
          {
            "node": "Split Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Email Work Order": {
      "main": [
        [
          {
            "node": "Split Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check if there is PDF file": {
      "main": [
        [
          {
            "node": "Switch",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Email only",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Email only": {
      "main": [
        [
          {
            "node": "AI Agent1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory1": {
      "ai_memory": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser": {
      "ai_outputParser": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent1": {
      "main": [
        [
          {
            "node": "Email Unwrapped Output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Work Order Set Fields": {
      "main": [
        [
          {
            "node": "Append row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "filters to origin per thread": {
      "main": [
        [
          {
            "node": "Check if there is PDF file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser1": {
      "ai_outputParser": [
        [
          {
            "node": "AI Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Get many labels": {
      "main": [
        []
      ]
    },
    "Get Emails": {
      "main": [
        [
          {
            "node": "Split Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FB - Check if threadId is exists otherwise create": {
      "main": [
        [
          {
            "node": "Get Id and Text for Facebook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SDR - Check if threadId is exists otherwise create": {
      "main": [
        [
          {
            "node": "Get Id and Text for SDR",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert row for ThreadId": {
      "main": [
        []
      ]
    },
    "WRnet - Check if threadId is exists otherwise create1": {
      "main": [
        [
          {
            "node": "Get Id and Text for Windowrevival.NET",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Switch": {
      "main": [
        [
          {
            "node": "PDF attached with metadata preserved",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Link with metadata preserved",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download PDF file from Link": {
      "main": [
        [
          {
            "node": "HTTP Request â†’ Read Binary File â†’ Extract Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PDF File â†’ Extract Text": {
      "main": [
        [
          {
            "node": "Merge PDF and Email Meta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Link with metadata preserved": {
      "main": [
        [
          {
            "node": "Download PDF file from Link",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request â†’ Read Binary File â†’ Extract Text": {
      "main": [
        [
          {
            "node": "Merge Link data and email Meta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Link data and email Meta": {
      "main": [
        [
          {
            "node": "Set Work Order Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PDF attached with metadata preserved": {
      "main": [
        [
          {
            "node": "PDF File â†’ Extract Text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge PDF and Email Meta": {
      "main": [
        [
          {
            "node": "Set Work Order Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Work Order Fields": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PDF Unwrapped Output ": {
      "main": [
        [
          {
            "node": "Work Order Set Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Email Unwrapped Output": {
      "main": [
        [
          {
            "node": "Work Order Set Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Work Order - Check if threadId is exists otherwise create1": {
      "main": [
        [
          {
            "node": "Build Email Meta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Work Order - Check if threadId is exists otherwise create": {
      "main": [
        [
          {
            "node": "Email only1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "b4cFEFv1eFePOnMh"
  },
  "staticData": {
    "node:Gmail Trigger": {
      "Gmail Trigger": {
        "lastTimeChecked": 1763427141,
        "possibleDuplicates": [
          "19a9472ca8f2fab6",
          "19a946dfe0b61dd3",
          "19a946bd84f6be6e",
          "19a946b0458f4fcf",
          "19a9469cc2a83387",
          "19a9468af00ed599",
          "19a9466cf92938d4",
          "19a945fd86ef412e",
          "19a945eb4bb2f4a8",
          "19a945767d761512",
          "19a9453a3ff698d7",
          "19a94516453f84b8",
          "19a944f7ba65087e",
          "19a944d0f69bd9ed",
          "19a944c587c61090",
          "19a944b1a9d19c7c",
          "19a944a718ca7c8d",
          "19a944939e627a34",
          "19a944784862f3f7",
          "19a94442ba7fdc2e",
          "19a94424a67cdfcd",
          "19a9440842ed2861",
          "19a943ea0493a8f2",
          "19a943cf0ec68dba",
          "19a943ca04569d7f",
          "19a9438df3d9db76",
          "19a94373ea78dc3b",
          "19a943261e82b3c3",
          "19a9429a0936ce4b",
          "19a94236a8815c51",
          "19a9421fbaaa3ea7",
          "19a941d5d1790060"
        ]
      }
    },
    "node:Trigger every 1 minute": {
      "recurrenceRules": []
    },
    "node:Trigger every 5 minute": {
      "recurrenceRules": []
    }
  },
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {},
  "versionId": "e6b71c8b-7839-40bb-9246-cf6881764104",
  "activeVersionId": "e6b71c8b-7839-40bb-9246-cf6881764104",
  "versionCounter": 729,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-02-03T01:37:20.616Z",
      "createdAt": "2026-02-03T01:37:20.616Z",
      "role": "workflow:owner",
      "workflowId": "NXvUDPpKfGxWETqO",
      "projectId": "6TsYTzg0HY92xH2K",
      "project": {
        "updatedAt": "2025-11-14T08:33:27.896Z",
        "createdAt": "2025-11-14T07:49:25.938Z",
        "id": "6TsYTzg0HY92xH2K",
        "name": "Christine Kam <windowrevival@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "bc31a112-3ed8-48ca-b94c-7225571c3d7b",
        "projectRelations": [
          {
            "updatedAt": "2025-11-14T07:49:25.938Z",
            "createdAt": "2025-11-14T07:49:25.938Z",
            "userId": "bc31a112-3ed8-48ca-b94c-7225571c3d7b",
            "projectId": "6TsYTzg0HY92xH2K",
            "user": {
              "updatedAt": "2026-02-10T14:01:06.000Z",
              "createdAt": "2025-11-14T07:49:14.641Z",
              "id": "bc31a112-3ed8-48ca-b94c-7225571c3d7b",
              "email": "windowrevival@gmail.com",
              "firstName": "Christine",
              "lastName": "Kam",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2025-11-14T08:34:38.735Z",
                "personalization_survey_n8n_version": "1.119.1",
                "automationGoalDevops": [
                  "reporting",
                  "other"
                ],
                "automationGoalDevopsOther": "Automate all apps",
                "companySize": "<20",
                "companyType": "systems-integrator",
                "role": "it",
                "reportedSource": "google"
              },
              "settings": {
                "userActivated": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "ZwjGOdSLvNlPoB1E",
                "userActivatedAt": 1763281773859,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1763554974919
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-02-11",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [
    {
      "updatedAt": "2025-11-25T13:05:18.454Z",
      "createdAt": "2025-11-25T13:05:18.454Z",
      "id": "xn6seEX74pkTOLqC",
      "name": "@lead"
    }
  ],
  "activeVersion": {
    "updatedAt": "2026-02-11T00:20:10.000Z",
    "createdAt": "2026-02-10T22:08:12.135Z",
    "versionId": "e6b71c8b-7839-40bb-9246-cf6881764104",
    "workflowId": "NXvUDPpKfGxWETqO",
    "nodes": [
      {
        "parameters": {
          "operation": "append",
          "documentId": {
            "__rl": true,
            "value": "13lFnQiBUmo1W0oQoTNlcn94ouflhuRWlMYu9NQV7taQ",
            "mode": "list",
            "cachedResultName": "Leads Logs",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/13lFnQiBUmo1W0oQoTNlcn94ouflhuRWlMYu9NQV7taQ/edit?usp=drivesdk"
          },
          "sheetName": {
            "__rl": true,
            "value": "gid=0",
            "mode": "list",
            "cachedResultName": "raw",
            "cachedResultUrl": "https://docs.google.com/spreadsheets/d/13lFnQiBUmo1W0oQoTNlcn94ouflhuRWlMYu9NQV7taQ/edit#gid=0"
          },
          "columns": {
            "mappingMode": "defineBelow",
            "value": {
              "Timestamp": "={{ $json.Timestamp }}",
              "Id": "={{ $json.Id }}",
              "Lead Type": "={{ $json['Lead Type'] }}",
              "First Name": "={{ $json['First Name'] }}",
              "Last Name": "={{ $json['Last Name'] }}",
              "Mobile Number": "={{ $json['Mobile Number'] }}",
              "Phone Number": "={{ $json['Phone Number'] }}",
              "Email Address": "={{ $json['Email Address'] }}",
              "Address": "={{ $json.Address }}",
              "State": "={{ $json.State }}",
              "Suburb": "={{ $json.Suburb }}",
              "Postal Code": "={{ $json['Postal Code'] }}",
              "Enquiry": "={{ $json.Enquiry }}",
              "Quantity": "={{ $json.Quantity }}",
              "Iâ€™d Like To Get My Project Underway": "={{ $json['I\\'d Like To Get My Project Underway'] }}",
              "How they heard about us": "={{ $json['How they heard about us'] }}",
              "Lead Qualifier": "={{ $json['Lead Qualifier'] }}",
              "Referred By": "={{ $json.referredBy }}"
            },
            "matchingColumns": [],
            "schema": [
              {
                "id": "Timestamp",
                "displayName": "Timestamp",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Id",
                "displayName": "Id",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Lead Type",
                "displayName": "Lead Type",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "First Name",
                "displayName": "First Name",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Last Name",
                "displayName": "Last Name",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Mobile Number",
                "displayName": "Mobile Number",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Phone Number",
                "displayName": "Phone Number",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Email Address",
                "displayName": "Email Address",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Address",
                "displayName": "Address",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "State",
                "displayName": "State",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Suburb",
                "displayName": "Suburb",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Postal Code",
                "displayName": "Postal Code",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Enquiry",
                "displayName": "Enquiry",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Quantity",
                "displayName": "Quantity",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Iâ€™d Like To Get My Project Underway",
                "displayName": "Iâ€™d Like To Get My Project Underway",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "How they heard about us",
                "displayName": "How they heard about us",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Lead Qualifier",
                "displayName": "Lead Qualifier",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true
              },
              {
                "id": "Referred By",
                "displayName": "Referred By",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "canBeUsedToMatch": true,
                "removed": false
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          },
          "options": {
            "useAppend": true
          }
        },
        "type": "n8n-nodes-base.googleSheets",
        "typeVersion": 4.7,
        "position": [
          3504,
          -320
        ],
        "id": "c88d9cab-c774-4e52-af35-78fa7f6136cc",
        "name": "Append row in sheet",
        "credentials": {
          "googleSheetsOAuth2Api": {
            "id": "S4FmXrss6MgN5rzt",
            "name": "WR: Google Sheets Account"
          }
        }
      },
      {
        "parameters": {
          "operation": "addLabels",
          "messageId": "={{ $json.Id }}",
          "labelIds": [
            "Label_169"
          ]
        },
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4176,
          -320
        ],
        "id": "72138bd5-c98c-49d0-bb1b-7e8c1923eea2",
        "name": "Add label to message",
        "webhookId": "d223a823-9177-4c4e-b398-48b487c46935",
        "credentials": {
          "gmailOAuth2": {
            "id": "Iacb6DlpUsfDqQMK",
            "name": "WR: Gmail Account"
          }
        }
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 2
            },
            "conditions": [
              {
                "id": "61b9b0d9-8451-470a-a782-ccf3201f846d",
                "leftValue": "={{ $json['Lead Qualifier'] }}",
                "rightValue": "Good",
                "operator": {
                  "type": "string",
                  "operation": "equals",
                  "name": "filter.operator.equals"
                }
              }
            ],
            "combinator": "or"
          },
          "options": {}
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          3728,
          -320
        ],
        "id": "fef28829-9863-4e53-8bad-e86424f7e7fa",
        "name": "If"
      },
      {
        "parameters": {
          "jsCode": "// =============== Helpers ===============\n\nfunction normalizeDigits(str) {\n  if (!str) return '';\n  return String(str).replace(/\\D+/g, '');\n}\n\n// Normalise any AU-looking phone number\nfunction normalizeAuPhone(raw) {\n  let digits = normalizeDigits(raw);\n  if (!digits) return '';\n\n  if (digits.startsWith('61')) {\n    digits = '0' + digits.slice(2);\n  }\n\n  if (!digits.startsWith('0') && digits.length === 9 && digits.startsWith('4')) {\n    digits = '0' + digits;\n  }\n\n  return digits;\n}\n\nfunction formatAuPhoneFromDigits(digits) {\n  if (!digits) return '';\n\n  if (digits.length === 10 && digits.startsWith('04')) {\n    return digits.replace(/(\\d{4})(\\d{3})(\\d{3})/, '$1 $2 $3');\n  }\n\n  if (digits.length === 10 && digits.startsWith('0')) {\n    return digits.replace(/(\\d{2})(\\d{4})(\\d{4})/, '$1 $2 $3');\n  }\n\n  return digits;\n}\n\nfunction getExecutionTimes() {\n  const now = new Date();\n  return {\n    executionBrisbane: now.toLocaleString('en-AU', {\n      timeZone: 'Australia/Brisbane',\n      hour12: false,\n    }),\n  };\n}\n\n// =============== ðŸ”’ PRIVYR SUMMARY DETECTION (NEW) ===============\n// These emails are NOT leads and must be ignored entirely\nfunction isPrivyrSummaryEmail(rawText) {\n  if (!rawText) return false;\n\n  const t = rawText.toLowerCase();\n\n  return (\n    t.includes('daily summary') ||\n    t.includes('uncontacted leads') ||\n    t.includes('upcoming activities') ||\n    t.includes('view all uncontacted leads') ||\n    t.includes('open privyr')\n  );\n}\n\n// -------------------- Spam Rules (UNCHANGED) --------------------\nconst BAD_NAME_WORDS = new Set([\n  'test','asdf','qwer','zxcv','xxxx','abc','123','sdr','null','none','na','n/a','demo'\n]);\n\nconst DISPOSABLE_DOMAINS = new Set([\n  'mailinator.com','tempmail.com','10minutemail.com','guerrillamail.com',\n  'yopmail.com','trashmail.com','sharklasers.com','getnada.com'\n]);\n\nfunction isLikelyGibberishName(name) {\n  const s = String(name || '').trim().toLowerCase();\n  if (!s) return true;\n\n  const cleaned = s.replace(/[^a-z\\s'\\-]/g, '');\n  const lettersOnly = cleaned.replace(/[^a-z]/g, '');\n\n  if (lettersOnly.length < 2) return true;\n  if (cleaned.length < s.length * 0.7) return true;\n\n  const vowels = (lettersOnly.match(/[aeiou]/g) || []).length;\n  const vowelRatio = vowels / lettersOnly.length;\n\n  const hasLongRepeat = /(.)\\1{3,}/.test(lettersOnly);\n  const hasConsonantRun = /[bcdfghjklmnpqrstvwxyz]{5,}/.test(lettersOnly);\n\n  if (lettersOnly.length <= 5) {\n    if (hasLongRepeat) return true;\n    if (hasConsonantRun && lettersOnly.length >= 5) return true;\n    return false;\n  }\n\n  if (vowelRatio < 0.22 || hasConsonantRun || hasLongRepeat) return true;\n  return false;\n}\n\nfunction hasBadNameWord(first, last) {\n  const f = String(first || '').trim().toLowerCase();\n  const l = String(last || '').trim().toLowerCase();\n  return BAD_NAME_WORDS.has(f) || BAD_NAME_WORDS.has(l) || (f + ' ' + l).includes('test');\n}\n\nfunction isDisposableEmail(email) {\n  const e = String(email || '').trim().toLowerCase();\n  const m = e.match(/@([a-z0-9.-]+\\.[a-z]{2,})$/);\n  return m ? DISPOSABLE_DOMAINS.has(m[1]) : false;\n}\n\nfunction isFakePhoneDigits(digits) {\n  const d = normalizeDigits(digits);\n  if (!d) return true;\n  if (d.length < 9) return true;\n  if (/^(\\d)\\1+$/.test(d)) return true;\n  if (d.includes('123456') || d.includes('00000')) return true;\n  return false;\n}\n\nfunction isSpamLead(parsed, mobileFormatted, phoneFormatted) {\n  const first = (parsed.firstName || '').trim();\n  const last  = (parsed.lastName  || '').trim();\n  const email = (parsed.email || '').trim();\n\n  const hasName = first.length >= 2 && last.length >= 2;\n\n  const mobileDigits = normalizeDigits(mobileFormatted || '');\n  const phoneDigits  = normalizeDigits(phoneFormatted || '');\n  const hasAnyPhone  = mobileDigits.length > 0 || phoneDigits.length > 0;\n\n  if (!hasName) return true;\n  if (!hasAnyPhone) return true;\n  if (hasBadNameWord(first, last)) return true;\n  if (isLikelyGibberishName(first) || isLikelyGibberishName(last)) return true;\n  if (email && isDisposableEmail(email)) return true;\n  if (isFakePhoneDigits(mobileDigits || phoneDigits)) return true;\n\n  return false;\n}\n\n// =============== Facebook Parser (UNCHANGED) ===============\n\nfunction parseFacebookText(rawText) {\n  if (!rawText) return {};\n  const text = rawText.replace(/\\s+/g, ' ');\n\n  const markerDefs = [\n    { key: 'comments',       marker: 'Comments/Questions:' },\n    { key: 'email',          marker: 'Email:' },\n    { key: 'firstName',      marker: 'First Name:' },\n    { key: 'lastName',       marker: 'Last Name:' },\n    { key: 'mobileRaw',      marker: 'Mobile Number:' },\n    { key: 'phoneNumberRaw', marker: 'Phone Number:' },\n    { key: 'service',        marker: 'Please Select What You Want Fixing::' },\n    { key: 'quantity',       marker: 'Quantity:' },\n    { key: 'timeFrame',      marker: 'Time Frame For Repairs?:' },\n    { key: 'suburb',         marker: 'Which Suburb?:' },\n  ];\n\n  const positions = [];\n  for (const m of markerDefs) {\n    const idx = text.indexOf(m.marker);\n    if (idx !== -1) {\n      positions.push({ key: m.key, markerIndex: idx, valueStart: idx + m.marker.length });\n    }\n  }\n\n  if (!positions.length) return {};\n\n  positions.sort((a, b) => a.markerIndex - b.markerIndex);\n\n  const result = {};\n  for (let i = 0; i < positions.length; i++) {\n    const curr = positions[i];\n    const next = positions[i + 1];\n    const end  = next ? next.markerIndex : text.length;\n    const value = text.slice(curr.valueStart, end).trim();\n    if (curr.key && value) result[curr.key] = value;\n  }\n\n  if (!result.email) {\n    const emailMatch = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n    if (emailMatch) result.email = emailMatch[0];\n  }\n\n  return result;\n}\n\n// =============== MAIN (WITH FILTER) ===============\n\nconst execTime = getExecutionTimes();\n\nreturn items\n  // ðŸš« HARD FILTER: ignore Privyr summary emails entirely\n  .filter(item => {\n    const rawText = item.json?.text || item.json?.textHtml || item.json?.snippet || '';\n    return !isPrivyrSummaryEmail(rawText);\n  })\n  .map(item => {\n    const json    = item.json || {};\n    const id      = json.id || '';\n    const rawText = json.text || json.textHtml || json.snippet || '';\n\n    const parsed = parseFacebookText(rawText);\n\n    let mobileFormatted = '';\n    let phoneFormatted  = '';\n\n    const mobileDigits = normalizeAuPhone(parsed.mobileRaw || '');\n    const phoneDigits  = normalizeAuPhone(parsed.phoneNumberRaw || '');\n\n    if (mobileDigits) {\n      mobileFormatted = mobileDigits.startsWith('04')\n        ? formatAuPhoneFromDigits(mobileDigits)\n        : mobileDigits;\n    }\n\n    if (phoneDigits) {\n      if (phoneDigits.startsWith('04')) {\n        mobileFormatted ||= formatAuPhoneFromDigits(phoneDigits);\n      } else {\n        phoneFormatted = phoneDigits.startsWith('0')\n          ? formatAuPhoneFromDigits(phoneDigits)\n          : phoneDigits;\n      }\n    }\n\n    const leadQualifier = isSpamLead(parsed, mobileFormatted, phoneFormatted) ? 'Spam' : 'Good';\n\n    return {\n      json: {\n        Timestamp: execTime.executionBrisbane,\n        Id: id,\n        'Lead Type': 'Facebook Lead',\n        'First Name': parsed.firstName || '',\n        'Last Name': parsed.lastName || '',\n        'Mobile Number': mobileFormatted,\n        'Phone Number': phoneFormatted,\n        'Email Address': parsed.email || '',\n        Address: '',\n        State: '',\n        Suburb: parsed.suburb || '',\n        'Postal Code': '',\n        Enquiry: parsed.comments || parsed.service || '',\n        Quantity: parsed.quantity || '',\n        \"I'd Like To Get My Project Underway\": parsed.timeFrame || '',\n        'How they heard about us': 'Facebook Marketing',\n        'Lead Qualifier': leadQualifier,\n      },\n    };\n  });\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3280,
          -304
        ],
        "id": "ee8ae6c2-4a7e-4e38-aa54-d98a168eef11",
        "name": "FB Parsing"
      },
      {
        "parameters": {
          "jsCode": "// items: array of input items from Gmail Get Many\n// each item.json has at least: { id, text }\n\n// =================== Utilities ===================\n\nfunction normalizeDigits(str) {\n  if (!str) return '';\n  return String(str).replace(/\\D+/g, '');\n}\n\nfunction formatAuPhone(raw, type) {\n  if (!raw) return '';\n  let digits = normalizeDigits(raw);\n  if (!digits) return '';\n\n  if (digits.startsWith('61')) {\n    digits = '0' + digits.slice(2);\n  } else if (!digits.startsWith('0') && digits.length >= 9) {\n    digits = '0' + digits;\n  }\n\n  if (type === 'mobile' && digits.length === 10) {\n    return digits.replace(/(\\d{4})(\\d{3})(\\d{3})/, '$1 $2 $3');\n  }\n\n  if (type === 'landline' && digits.length === 10) {\n    return digits.replace(/(\\d{2})(\\d{4})(\\d{4})/, '$1 $2 $3');\n  }\n\n  return digits;\n}\n\nfunction getBrisbaneDate(json) {\n  const date = json.internalDate ? new Date(Number(json.internalDate)) : new Date();\n  return date.toLocaleString('en-AU', { timeZone: 'Australia/Brisbane', hour12: false });\n}\n\n// =================== CLEAN PROJECT TIMING ===================\n\nfunction cleanProjectTiming(value) {\n  if (!value) return '';\n\n  const STOP_WORDS = [\n    'How did yopu here about us',\n    'How did you hear about us',\n    'How they heard about us',\n    'Services',\n    'Brands'\n  ];\n\n  let cleaned = value;\n\n  // Cut at known boundaries\n  for (const stop of STOP_WORDS) {\n    const idx = cleaned.indexOf(stop);\n    if (idx !== -1) {\n      cleaned = cleaned.slice(0, idx);\n    }\n  }\n\n  // Remove Gmail / HTML junk like \"...\"\n  cleaned = cleaned\n    .replace(/^\\s*\\.{2,}/, '')   // remove \"..\" / \"...\"\n    .replace(/^[\\s:â€“â€”-]+/, '')   // leading punctuation\n    .trim();\n\n  // If only dots existed, return empty\n  if (/^\\.*$/.test(cleaned)) return '';\n\n  return cleaned;\n}\n\n// =================== Parser ===================\n\nfunction parseFormText(rawText) {\n  if (!rawText) return {};\n\n  const text = rawText.replace(/\\r?\\n/g, ' ');\n\n  const markerDefs = [\n    { key: 'firstName',      marker: 'First Name' },\n    { key: 'lastName',       marker: 'Last Name' },\n    { key: 'email',          marker: 'Email' },\n    { key: 'mobileRaw',      marker: 'Mobile Number' },\n    { key: 'phoneNumberRaw', marker: 'Phone Number' },\n    { key: 'address',        marker: 'Address' },\n    { key: 'suburb',         marker: 'Suburb' },\n    { key: 'state',          marker: 'State' },\n    { key: 'postalCode',     marker: 'Postal Code' },\n    { key: 'enquiry',        marker: 'Enquiry' },\n    { key: 'projectTiming',  marker: \"I'd Like To Get My Project Underway\" },\n    { key: 'quantity',       marker: 'Quantity' },\n\n    // Boundaries\n    { key: null, marker: 'How did yopu here about us' },\n    { key: null, marker: 'How did you hear about us' },\n    { key: null, marker: 'How they heard about us' },\n    { key: null, marker: 'Brands' },\n    { key: null, marker: 'Services' }\n  ];\n\n  const positions = [];\n  for (const m of markerDefs) {\n    const idx = text.indexOf(m.marker);\n    if (idx === -1) continue;\n    positions.push({ key: m.key, markerIndex: idx, valueStart: idx + m.marker.length });\n  }\n\n  if (!positions.length) return {};\n\n  positions.sort((a, b) => a.markerIndex - b.markerIndex);\n\n  const result = {};\n  for (let i = 0; i < positions.length; i++) {\n    const curr = positions[i];\n    const next = positions[i + 1];\n    const end = next ? next.markerIndex : text.length;\n    const value = text.slice(curr.valueStart, end).trim();\n    if (curr.key && value && !result[curr.key]) result[curr.key] = value;\n  }\n\n  if (!result.email) {\n    const emailMatch = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n    if (emailMatch) result.email = emailMatch[0];\n  }\n\n  return result;\n}\n\n// =================== Spam Rules ===================\n\nconst BAD_NAME_WORDS = new Set([\n  'test','asdf','qwer','zxcv','xxxx','abc','123','sdr','null','none','na','n/a','demo'\n]);\n\nconst DISPOSABLE_DOMAINS = new Set([\n  'mailinator.com','tempmail.com','10minutemail.com','guerrillamail.com',\n  'yopmail.com','trashmail.com','sharklasers.com','getnada.com'\n]);\n\nfunction isLikelyGibberishName(name) {\n  const s = String(name || '').trim().toLowerCase();\n  if (!s) return true;\n\n  const cleaned = s.replace(/[^a-z\\s'\\-]/g, '');\n  const lettersOnly = cleaned.replace(/[^a-z]/g, '');\n\n  if (lettersOnly.length < 2) return true;\n  if (cleaned.length < s.length * 0.7) return true;\n\n  const vowels = (lettersOnly.match(/[aeiou]/g) || []).length;\n  const vowelRatio = vowels / lettersOnly.length;\n  const hasLongRepeat = /(.)\\1{3,}/.test(lettersOnly);\n  const hasConsonantRun = /[bcdfghjklmnpqrstvwxyz]{5,}/.test(lettersOnly);\n\n  if (lettersOnly.length <= 5) {\n    if (hasLongRepeat) return true;\n    if (hasConsonantRun && lettersOnly.length >= 5) return true;\n    return false;\n  }\n\n  if (vowelRatio < 0.22 || hasConsonantRun || hasLongRepeat) return true;\n  return false;\n}\n\nfunction hasBadNameWord(first, last) {\n  const f = String(first || '').toLowerCase();\n  const l = String(last || '').toLowerCase();\n  return BAD_NAME_WORDS.has(f) || BAD_NAME_WORDS.has(l) || (f + ' ' + l).includes('test');\n}\n\nfunction isDisposableEmail(email) {\n  const m = String(email || '').toLowerCase().match(/@([a-z0-9.-]+\\.[a-z]{2,})$/);\n  return m ? DISPOSABLE_DOMAINS.has(m[1]) : false;\n}\n\nfunction isFakePhoneDigits(digits) {\n  const d = normalizeDigits(digits);\n  if (!d || d.length < 9) return true;\n  if (/^(\\d)\\1+$/.test(d)) return true;\n  if (d.includes('123456') || d.includes('00000')) return true;\n  return false;\n}\n\nfunction isSpamLead(parsed, mobileFormatted, phoneFormatted) {\n  const first = (parsed.firstName || '').trim();\n  const last  = (parsed.lastName  || '').trim();\n  const email = (parsed.email || '').trim();\n\n  const mobileDigits = normalizeDigits(mobileFormatted || '');\n  const phoneDigits  = normalizeDigits(phoneFormatted || '');\n  const hasAnyPhone = mobileDigits.length > 0 || phoneDigits.length > 0;\n\n  if (first.length < 2 || last.length < 2) return true;\n  if (!hasAnyPhone) return true;\n  if (hasBadNameWord(first, last)) return true;\n  if (isLikelyGibberishName(first) || isLikelyGibberishName(last)) return true;\n  if (email && isDisposableEmail(email)) return true;\n  if (isFakePhoneDigits(mobileDigits || phoneDigits)) return true;\n\n  return false;\n}\n\n// =================== MAIN ===================\n\nreturn items.map(item => {\n  const json = item.json || {};\n  const rawText = json.text || json.textPlain || json.snippet || '';\n  const parsed = parseFormText(rawText);\n\n  let mobileFormatted = '';\n  let phoneFormatted  = '';\n\n  if (parsed.mobileRaw) {\n    mobileFormatted = formatAuPhone(parsed.mobileRaw, 'mobile');\n  }\n\n  if (parsed.phoneNumberRaw) {\n    const digits = normalizeDigits(parsed.phoneNumberRaw);\n    if (digits.startsWith('04')) {\n      mobileFormatted ||= formatAuPhone(parsed.phoneNumberRaw, 'mobile');\n    } else {\n      phoneFormatted = formatAuPhone(parsed.phoneNumberRaw, 'landline');\n    }\n  }\n\n  const leadQualifier = isSpamLead(parsed, mobileFormatted, phoneFormatted) ? 'Spam' : 'Good';\n\n  return {\n    json: {\n      Timestamp: getBrisbaneDate(json),\n      Id: json.id || '',\n\n      'Lead Type': 'Windowrevival.NET Lead',\n\n      'First Name': parsed.firstName || '',\n      'Last Name':  parsed.lastName  || '',\n      'Mobile Number': mobileFormatted,\n      'Phone Number':  phoneFormatted,\n      'Email Address': parsed.email || '',\n      'Address': parsed.address || '',\n      State: parsed.state || '',\n      Suburb: parsed.suburb || '',\n      'Postal Code': parsed.postalCode || '',\n      Enquiry: parsed.enquiry || '',\n      Quantity: parsed.quantity || '',\n\n      // âœ… FIXED FIELD\n      \"I'd Like To Get My Project Underway\": cleanProjectTiming(parsed.projectTiming),\n\n      'How they heard about us': 'WRnet Website',\n      'Lead Qualifier': leadQualifier,\n      referredBy: '',\n    },\n  };\n});\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3280,
          -496
        ],
        "id": "d370cc05-05c3-4faa-a05b-952b06e94f87",
        "name": "Windowrevival.NET Parsing"
      },
      {
        "parameters": {
          "jsCode": "// =================== Utilities ===================\n\nfunction normalizeDigits(str) {\n  if (!str) return '';\n  return String(str).replace(/\\D+/g, '');\n}\n\nfunction formatAuPhone(raw, type) {\n  if (!raw) return '';\n  let digits = normalizeDigits(raw);\n  if (!digits) return '';\n\n  if (digits.startsWith('61')) {\n    digits = '0' + digits.slice(2);\n  } else if (!digits.startsWith('0') && digits.length >= 9) {\n    digits = '0' + digits;\n  }\n\n  if (type === 'mobile' && digits.length === 10) {\n    return digits.replace(/(\\d{4})(\\d{3})(\\d{3})/, '$1 $2 $3');\n  }\n\n  if (type === 'landline' && digits.length === 10) {\n    return digits.replace(/(\\d{2})(\\d{4})(\\d{4})/, '$1 $2 $3');\n  }\n\n  return digits;\n}\n\nfunction getBrisbaneDate(json) {\n  const date = json.internalDate ? new Date(Number(json.internalDate)) : new Date();\n  return date.toLocaleString('en-AU', { timeZone: 'Australia/Brisbane', hour12: false });\n}\n\n// =================== CLEAN PROJECT TIMING FIX ===================\n\nfunction cleanProjectTiming(value) {\n  if (!value) return '';\n\n  const STOP_WORDS = [\n    'How did yopu here about us',\n    'How did you hear about us',\n    'How they heard about us',\n    'Services',\n    'Brands'\n  ];\n\n  let cleaned = value;\n\n  for (const stop of STOP_WORDS) {\n    const idx = cleaned.indexOf(stop);\n    if (idx !== -1) cleaned = cleaned.slice(0, idx);\n  }\n\n  cleaned = cleaned\n    .replace(/^\\s*\\.{2,}/, '')\n    .replace(/^[\\s:â€“â€”-]+/, '')\n    .trim();\n\n  return cleaned;\n}\n\n// =================== Parser ===================\n\nfunction parseFormText(rawText) {\n  if (!rawText) return {};\n  const text = rawText.replace(/\\r?\\n/g, ' ');\n  const lower = text.toLowerCase();\n\n  const markerDefs = [\n    { key: 'firstName', marker: 'First Name' },\n    { key: 'lastName', marker: 'Last Name' },\n    { key: 'email', marker: 'Email' },\n    { key: 'mobileRaw', marker: 'Mobile Number' },\n    { key: 'phoneNumberRaw', marker: 'Phone Number' },\n    { key: 'suburb', marker: 'Suburb' },\n    { key: 'state', marker: 'State' },\n    { key: 'enquiry', marker: 'Enquiry' },\n    { key: 'projectTiming', marker: \"I'd Like To Get My Project Underway\" },\n    { key: 'quantity', marker: 'Quantity' }\n  ];\n\n  const positions = [];\n  for (const m of markerDefs) {\n    const idx = lower.indexOf(m.marker.toLowerCase());\n    if (idx !== -1) {\n      positions.push({ key: m.key, markerIndex: idx, valueStart: idx + m.marker.length });\n    }\n  }\n\n  if (!positions.length) return {};\n  positions.sort((a, b) => a.markerIndex - b.markerIndex);\n\n  const result = {};\n  for (let i = 0; i < positions.length; i++) {\n    const curr = positions[i];\n    const next = positions[i + 1];\n    const end = next ? next.markerIndex : text.length;\n    const value = text.slice(curr.valueStart, end).trim();\n    if (curr.key && value && !result[curr.key]) result[curr.key] = value;\n  }\n\n  if (!result.email) {\n    const emailMatch = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n    if (emailMatch) result.email = emailMatch[0];\n  }\n\n  return result;\n}\n\n// =================== Name handling (multi-word) ===================\n\nfunction splitFullName(firstRaw, lastRaw) {\n  const f = String(firstRaw || '').trim();\n  const l = String(lastRaw || '').trim();\n\n  if (f && l) return { firstName: f, lastName: l };\n\n  const full = (f || l).trim();\n  if (!full) return { firstName: '', lastName: '' };\n\n  const parts = full.split(/\\s+/).filter(Boolean);\n  if (parts.length === 1) return { firstName: parts[0], lastName: '' };\n  return { firstName: parts[0], lastName: parts.slice(1).join(' ') };\n}\n\n// =================== Spam Rules ===================\n\nconst BAD_NAME_WORDS = new Set([\n  'test','asdf','qwer','zxcv','xxxx','abc','123','sdr','null','none','na','n/a','demo'\n]);\n\nconst DISPOSABLE_DOMAINS = new Set([\n  'mailinator.com','tempmail.com','10minutemail.com','guerrillamail.com',\n  'yopmail.com','trashmail.com','sharklasers.com','getnada.com'\n]);\n\nfunction isLikelyGibberishName(name) {\n  const s = String(name || '').trim().toLowerCase();\n  if (!s) return true;\n\n  const cleaned = s.replace(/[^a-z\\s'\\-]/g, '');\n  const lettersOnly = cleaned.replace(/[^a-z]/g, '');\n\n  if (lettersOnly.length < 2) return true;\n  if (cleaned.length < s.length * 0.7) return true;\n\n  const vowels = (lettersOnly.match(/[aeiou]/g) || []).length;\n  const vowelRatio = vowels / lettersOnly.length;\n  const hasLongRepeat = /(.)\\1{3,}/.test(lettersOnly);\n  const hasConsonantRun = /[bcdfghjklmnpqrstvwxyz]{5,}/.test(lettersOnly);\n\n  // For very short tokens, avoid false positives\n  if (lettersOnly.length <= 5) {\n    if (hasLongRepeat) return true;\n    if (hasConsonantRun && lettersOnly.length >= 5) return true;\n    return false;\n  }\n\n  if (vowelRatio < 0.22 || hasConsonantRun || hasLongRepeat) return true;\n  return false;\n}\n\nfunction hasBadNameWord(first, last) {\n  const f = String(first || '').toLowerCase();\n  const l = String(last || '').toLowerCase();\n  return BAD_NAME_WORDS.has(f) || BAD_NAME_WORDS.has(l) || (f + ' ' + l).includes('test');\n}\n\nfunction isDisposableEmail(email) {\n  const m = String(email || '').toLowerCase().match(/@([a-z0-9.-]+\\.[a-z]{2,})$/);\n  return m ? DISPOSABLE_DOMAINS.has(m[1]) : false;\n}\n\nfunction isFakePhoneDigits(digits) {\n  const d = normalizeDigits(digits);\n  if (!d || d.length < 9) return true;\n  if (/^(\\d)\\1+$/.test(d)) return true;\n  if (d.includes('123456') || d.includes('00000')) return true;\n  return false;\n}\n\n// =================== Loosened Spam Decision (score-based) ===================\n\nfunction isSpamLead(parsed, mobileFormatted, phoneFormatted) {\n  const first = (parsed.firstName || '').trim();\n  const last = (parsed.lastName || '').trim();\n  const email = (parsed.email || '').trim();\n  const enquiry = (parsed.enquiry || '').trim();\n\n  const mobileDigits = normalizeDigits(mobileFormatted);\n  const phoneDigits = normalizeDigits(phoneFormatted);\n  const hasAnyPhone = mobileDigits.length > 0 || phoneDigits.length > 0;\n\n  let score = 0;\n\n  // Strong signals\n  if (hasBadNameWord(first, last)) score += 3;\n  if (email && isDisposableEmail(email)) score += 3;\n  if (isFakePhoneDigits(mobileDigits || phoneDigits)) score += 3;\n\n  // Medium signals\n  if (!hasAnyPhone) score += 2;\n  if (!email) score += 1;\n  if (!enquiry || enquiry.length < 8) score += 1;\n\n  // Name length (allow short real names)\n  if (first.length < 2) score += 2;\n  if (last.length < 2) score += 1;\n\n  // Only run gibberish detector on longer tokens\n  if (first.length >= 5 && isLikelyGibberishName(first)) score += 2;\n  if (last.length >= 5 && isLikelyGibberishName(last)) score += 2;\n\n  return score >= 4;\n}\n\n// =================== MAIN ===================\n\nreturn items.map(item => {\n  const json = item.json || {};\n  const rawText = json.text || json.textPlain || json.snippet || '';\n  const parsed = parseFormText(rawText);\n\n  // Normalize names (supports multi-word + full-name-in-one-field cases)\n  const name = splitFullName(parsed.firstName, parsed.lastName);\n  parsed.firstName = name.firstName;\n  parsed.lastName = name.lastName;\n\n  let mobileFormatted = '';\n  let phoneFormatted = '';\n\n  if (parsed.mobileRaw) {\n    mobileFormatted = formatAuPhone(parsed.mobileRaw, 'mobile');\n  }\n\n  if (parsed.phoneNumberRaw) {\n    const digits = normalizeDigits(parsed.phoneNumberRaw);\n    if (digits.startsWith('04')) {\n      mobileFormatted ||= formatAuPhone(parsed.phoneNumberRaw, 'mobile');\n    } else {\n      phoneFormatted = formatAuPhone(parsed.phoneNumberRaw, 'landline');\n    }\n  }\n\n  const leadQualifier = isSpamLead(parsed, mobileFormatted, phoneFormatted) ? 'Spam' : 'Good';\n\n  return {\n    json: {\n      Timestamp: getBrisbaneDate(json),\n      Id: json.id || '',\n      'Lead Type': 'Sliding Door Lead',\n      'First Name': parsed.firstName || '',\n      'Last Name': parsed.lastName || '',\n      'Mobile Number': mobileFormatted,\n      'Phone Number': phoneFormatted,\n      'Email Address': parsed.email || '',\n      Address: '',\n      State: parsed.state || '',\n      Suburb: parsed.suburb || '',\n      'Postal Code': '',\n      Enquiry: parsed.enquiry || '',\n      Quantity: parsed.quantity || '',\n\n      // IMPORTANT: use the exact key your schema expects (curly apostrophe)\n      \"Iâ€™d Like To Get My Project Underway\": cleanProjectTiming(parsed.projectTiming),\n\n      'How they heard about us': 'SDR Website',\n      'Lead Qualifier': leadQualifier,\n\n      // IMPORTANT: exact key casing for schema\n      referredBy: ''\n    }\n  };\n});\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3280,
          -688
        ],
        "id": "0b2f7e89-e0a6-44da-8038-a468c7221cd7",
        "name": "SDR Parsing"
      },
      {
        "parameters": {
          "resource": "message",
          "guildId": {
            "__rl": true,
            "value": "753455160209965106",
            "mode": "list",
            "cachedResultName": "Window Revival",
            "cachedResultUrl": "https://discord.com/channels/753455160209965106"
          },
          "channelId": {
            "__rl": true,
            "value": "912496260823519232",
            "mode": "list",
            "cachedResultName": "leadsãƒ»new",
            "cachedResultUrl": "https://discord.com/channels/753455160209965106/912496260823519232"
          },
          "content": "===========\nLead Type: {{ $json['Lead Type'] }}\nTimestamp: {{ $json.Timestamp }}\nId: {{ $json.Id }}\nFirst Name: {{ $json['First Name'] }}\nLast Name: {{ $json['Last Name'] }}\nMobile Number: {{ $json['Mobile Number'] }}\nPhone Number: {{ $json['Phone Number'] }}\nEmail Address: {{ $json['Email Address'] }}\nAddress: {{ $json.Address }}\nState: {{ $json.State }}\nSuburb: {{ $json.Suburb }}\nPostal Code: {{ $json['Postal Code'] }}\nEnquiry: {{ $json.Enquiry }}\nQuantity: {{ $json.Quantity }}\nI'd Like To Get my Project Underway: {{ $json['Iâ€™d Like To Get My Project Underway'] }}\nHow they heard about us?: {{ $json['How they heard about us'] }}",
          "options": {}
        },
        "type": "n8n-nodes-base.discord",
        "typeVersion": 2,
        "position": [
          4176,
          -128
        ],
        "id": "be7045d4-c862-419b-9d28-8f124713018d",
        "name": "Send a message",
        "webhookId": "3825e270-76f5-472d-ba19-ea9f542a60c8",
        "credentials": {
          "discordBotApi": {
            "id": "a0FDlWFh8PBA5Add",
            "name": "WR: Discord Bot Account"
          }
        }
      },
      {
        "parameters": {
          "operation": "delete",
          "messageId": "={{ $json.id }}"
        },
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          4400,
          256
        ],
        "id": "0e874fe4-2c21-40ec-9712-63dc4230fced",
        "name": "Delete spam email",
        "webhookId": "de4c9c81-e1b4-446d-8230-0c15ed712c16",
        "credentials": {
          "gmailOAuth2": {
            "id": "Iacb6DlpUsfDqQMK",
            "name": "WR: Gmail Account"
          }
        }
      },
      {
        "parameters": {
          "operation": "get",
          "messageId": "={{ $json.Id }}"
        },
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          3952,
          256
        ],
        "id": "412596bc-f04e-4215-89fc-974f18375037",
        "name": "Check id if exist before deleting",
        "webhookId": "2052dce9-a67d-47eb-8004-388bf3af2164",
        "credentials": {
          "gmailOAuth2": {
            "id": "Iacb6DlpUsfDqQMK",
            "name": "WR: Gmail Account"
          }
        },
        "onError": "continueRegularOutput"
      },
      {
        "parameters": {
          "method": "POST",
          "options": {}
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.3,
        "position": [
          3952,
          -416
        ],
        "id": "9ac2169e-f789-43b8-88ca-ad6fdc087d24",
        "name": "Send to Wrapp",
        "disabled": true
      },
      {
        "parameters": {
          "jsCode": "// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  item.json.myNewField = 1;\n}\n\nreturn $input.all();"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          4176,
          256
        ],
        "id": "97d142a3-74b4-45ec-8d43-eea863a3e07a",
        "name": "Get Ids"
      },
      {
        "parameters": {
          "amount": 10
        },
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          3952,
          -224
        ],
        "id": "1d0630eb-0133-40a6-adf3-96d4ad94b73f",
        "name": "Wait",
        "webhookId": "c4924f00-19cd-4a7f-bbd7-18c5cdb1a70d"
      },
      {
        "parameters": {
          "rule": {
            "interval": [
              {
                "field": "minutes"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.scheduleTrigger",
        "typeVersion": 1.2,
        "position": [
          -1664,
          -208
        ],
        "id": "58e39806-9b28-404e-b01a-e097bb52b3c2",
        "name": "Trigger every 5 minute"
      },
      {
        "parameters": {
          "amount": 1
        },
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          -1440,
          -224
        ],
        "id": "de027805-4233-4889-bb49-f96b51b51e3b",
        "name": "Wait1",
        "webhookId": "2a72056d-7af1-47ed-a608-b34bb05075a3"
      },
      {
        "parameters": {
          "amount": 1
        },
        "type": "n8n-nodes-base.wait",
        "typeVersion": 1.1,
        "position": [
          -768,
          -224
        ],
        "id": "1704f0a6-effa-4108-bd7e-edb8054a03b1",
        "name": "Wait2",
        "webhookId": "254ef1fd-13c3-4cf0-b858-53d35191ca63"
      },
      {
        "parameters": {
          "fieldToSplitOut": "id",
          "options": {}
        },
        "type": "n8n-nodes-base.splitOut",
        "typeVersion": 1,
        "position": [
          -992,
          -224
        ],
        "id": "65428fe0-0747-4525-bcb7-8da127e20727",
        "name": "Split Emails"
      },
      {
        "parameters": {
          "rules": {
            "values": [
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "loose",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $json.labelIds || [] }}\n",
                      "rightValue": "Label_236316694232257385",
                      "operator": {
                        "type": "string",
                        "operation": "contains"
                      },
                      "id": "853ec203-7401-4dd6-a636-9c3e2f143ce3"
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "SDR"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "loose",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "id": "73d43b3e-4e0a-42e5-a797-65e5a4ca424f",
                      "leftValue": "={{ $json.labelIds || [] }}",
                      "rightValue": "Label_5972230113927178957",
                      "operator": {
                        "type": "string",
                        "operation": "contains"
                      }
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "WR.net"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "loose",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "id": "dfdfd523-8675-4581-96b9-a2da47598c30",
                      "leftValue": "={{ $json.labelIds || [] }}",
                      "rightValue": "Label_4464659176251527724",
                      "operator": {
                        "type": "string",
                        "operation": "contains"
                      }
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "Facebook"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "loose",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "id": "b2a6c721-b36e-4492-ab27-200dd405c2da",
                      "leftValue": "={{ \n  $json.labelIds?.includes('Label_4746392800957065361') \n  && \n  $json.labelIds?.includes('Label_7577132244279306906') \n}}\n",
                      "rightValue": "3. Leads/3.8 Email Enquiry Gen",
                      "operator": {
                        "type": "boolean",
                        "operation": "true",
                        "singleValue": true
                      }
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "Email Enquiry"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "loose",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "id": "38cee0bf-368d-41db-a96e-e03566c8ef72",
                      "leftValue": "={{ $json.labelIds || [] }}",
                      "rightValue": "Label_8054278402706687750",
                      "operator": {
                        "type": "string",
                        "operation": "contains"
                      }
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "Work Order/Quote Order"
              }
            ]
          },
          "looseTypeValidation": true,
          "options": {}
        },
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3.4,
        "position": [
          128,
          -272
        ],
        "id": "7ea1e50d-3167-4bac-bdc5-3addafdbb94d",
        "name": "Router"
      },
      {
        "parameters": {
          "operation": "get",
          "messageId": "={{ $json.id }}",
          "simple": false,
          "options": {
            "downloadAttachments": true
          }
        },
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.2,
        "position": [
          -544,
          -224
        ],
        "id": "2c3ff578-cac6-477b-9f27-e5700eb03034",
        "name": "Get a message",
        "webhookId": "ce396636-538a-46bb-aa54-5da8848c5e97",
        "credentials": {
          "gmailOAuth2": {
            "id": "Iacb6DlpUsfDqQMK",
            "name": "WR: Gmail Account"
          }
        }
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 2
            },
            "conditions": [
              {
                "id": "e570add7-64c9-4339-b667-670a56ad8fa0",
                "leftValue": "={{ $json[\"labelIds\"].join(\",\") }}\n\n",
                "rightValue": "=Label_169",
                "operator": {
                  "type": "string",
                  "operation": "notContains"
                }
              }
            ],
            "combinator": "and"
          },
          "options": {}
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.2,
        "position": [
          -320,
          -224
        ],
        "id": "9df6c7b0-ac07-4840-9fe7-8c75e5f7719e",
        "name": "Ensure no label \"Label_169\" or Processed by n8n pass"
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
                "name": "id",
                "value": "={{ $json.id }}",
                "type": "string"
              },
              {
                "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
                "name": "text",
                "value": "={{ $json.text }}",
                "type": "string"
              }
            ]
          },
          "options": {}
        },
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          3056,
          -688
        ],
        "id": "21d35ad8-37f5-406a-8f7b-c9b128f72102",
        "name": "Get Id and Text for SDR"
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
                "name": "id",
                "value": "={{ $json.id }}",
                "type": "string"
              },
              {
                "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
                "name": "text",
                "value": "={{ $json.text }}",
                "type": "string"
              }
            ]
          },
          "options": {}
        },
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          3056,
          -496
        ],
        "id": "587ab281-b25f-438b-a3a3-a875afd4ac0d",
        "name": "Get Id and Text for Windowrevival.NET"
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
                "name": "id",
                "value": "={{ $json.id }}",
                "type": "string"
              },
              {
                "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
                "name": "text",
                "value": "={{ $json.text }}",
                "type": "string"
              }
            ]
          },
          "options": {}
        },
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          3056,
          -304
        ],
        "id": "f629fa32-4851-4926-8a45-9d8962a8fa48",
        "name": "Get Id and Text for Facebook"
      },
      {
        "parameters": {
          "resource": "label",
          "limit": 10
        },
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.2,
        "position": [
          -1440,
          -32
        ],
        "id": "dc716a58-baad-44f3-9bd6-a8d3e5628efc",
        "name": "Get many labels",
        "webhookId": "81da1f73-297d-4755-9c64-5df63073b9ac",
        "credentials": {
          "gmailOAuth2": {
            "id": "Iacb6DlpUsfDqQMK",
            "name": "WR: Gmail Account"
          }
        },
        "disabled": true
      },
      {
        "parameters": {
          "jsCode": "// This node \"freezes\" attachment metadata into JSON while keeping binary intact.\n// Router/other nodes sometimes drop binary; this reduces surprises and makes\n// downstream PDF filtering easier.\n\nreturn items.map(item => {\n  const bin = item.binary || {};\n  const attachments = Object.keys(bin).map(key => {\n    const b = bin[key] || {};\n    return {\n      key,                               // binary key like attachment_0\n      fileName: b.fileName || '',\n      mimeType: b.mimeType || '',\n      fileExtension: b.fileExtension || '',\n      fileSize: b.fileSize || 0,\n    };\n  });\n\n  item.json.attachments = attachments;\n  item.json.pdfAttachments = attachments.filter(a =>\n    (a.mimeType || '').toLowerCase() === 'application/pdf' ||\n    (a.fileExtension || '').toLowerCase() === 'pdf' ||\n    (a.fileName || '').toLowerCase().endsWith('.pdf')\n  );\n\n  item.json.pdfCount = item.json.pdfAttachments.length;\n\n  return item;\n});\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -96,
          -224
        ],
        "id": "71bee930-d747-405e-8d9e-06007c7f9bde",
        "name": "Preserve attachments"
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "loose",
              "version": 3
            },
            "conditions": [
              {
                "id": "db6a1784-302c-49c1-a31d-cbec0d44128a",
                "leftValue": "={{ \n  Object.values($binary || {}).some(b => {\n    const mime = (b.mimeType || '').toLowerCase();\n    const name = (b.fileName || '').toLowerCase();\n    return mime === 'application/pdf' || mime.includes('pdf') || name.endsWith('.pdf');\n  })\n}}\n",
                "rightValue": "",
                "operator": {
                  "type": "boolean",
                  "operation": "true",
                  "singleValue": true
                }
              }
            ],
            "combinator": "and"
          },
          "looseTypeValidation": true,
          "options": {}
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.3,
        "position": [
          -1664,
          1440
        ],
        "id": "2da66561-af77-4ccc-bc0a-3a6997b92a10",
        "name": "Has PDF?",
        "disabled": true
      },
      {
        "parameters": {
          "fieldToSplitOut": "attachment",
          "include": "allOtherFields",
          "options": {}
        },
        "type": "n8n-nodes-base.splitOut",
        "typeVersion": 1,
        "position": [
          -1664,
          2112
        ],
        "id": "f3d08a0c-5f9c-4af0-835d-9ac1418f777a",
        "name": "Extract PDF text"
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
                "name": "id",
                "value": "={{ $json.id }}",
                "type": "string"
              },
              {
                "id": "dc93f011-914a-435f-a2b9-89a3781ad46f",
                "name": "threadId",
                "value": "={{ $json.threadId }}",
                "type": "string"
              },
              {
                "id": "6b5505e7-19ca-4065-b162-c9ce00799f7f",
                "name": "from",
                "value": "={{ $json.from?.value?.[0]?.address || $json.headers?.from || '' }}\n\n",
                "type": "string"
              },
              {
                "id": "738733ee-2ed9-4a25-997d-7d69288cae20",
                "name": "subject",
                "value": "={{ $json.subject || ($json.headers?.subject ?? '') }}\n",
                "type": "string"
              },
              {
                "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
                "name": "emailText",
                "value": "={{ $json.text || '' }}\n",
                "type": "string"
              },
              {
                "id": "35fd5361-ac87-471c-b521-02be618e69d5",
                "name": "emailHtml",
                "value": "={{ $json.textAsHtml || '' }}",
                "type": "string"
              }
            ]
          },
          "includeOtherFields": true,
          "options": {}
        },
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          -1664,
          1664
        ],
        "id": "422ae798-1507-430c-86b4-77f2f880d49a",
        "name": "Get email meta for WorkOrder/QuoteOrder",
        "disabled": true
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "015be041-8c3c-4249-885b-d693bc855db6",
                "name": "id",
                "value": "={{ $json.id }}\n",
                "type": "string"
              },
              {
                "id": "e055ef97-d725-4e83-9e92-a3dcc6b1f999",
                "name": "threadId",
                "value": "={{ $json.threadId }}\n",
                "type": "string"
              },
              {
                "id": "9f559eb6-2656-4aae-9367-4302b6530cb7",
                "name": "from",
                "value": "={{ $json.from?.value?.[0]?.address ?? $json.from ?? \"\" }}\n",
                "type": "string"
              },
              {
                "id": "8d11132e-6892-45ad-bf4c-2c5453e0b463",
                "name": "emailText",
                "value": "={{ $json.text ?? $json.snippet ?? \"\" }}\n",
                "type": "string"
              },
              {
                "id": "52bcb2fe-303f-4287-9d2c-bac0825e4488",
                "name": "emailHtml",
                "value": "={{ $json.html ?? \"\" }}",
                "type": "string"
              },
              {
                "id": "07b2ae01-0f69-43f8-b855-7b408a05d9f2",
                "name": "pdfText",
                "value": "\"\"",
                "type": "string"
              },
              {
                "id": "47557d74-734c-43db-8b2e-984a92676a00",
                "name": "pdfCount",
                "value": 0,
                "type": "number"
              },
              {
                "id": "44c2bdf3-77a6-4a03-bd94-1cb6aed07283",
                "name": "pdfFiles",
                "value": "[]",
                "type": "array"
              }
            ]
          },
          "options": {}
        },
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          -1664,
          1888
        ],
        "id": "0d48cc61-2c41-475a-85df-88b480da5b01",
        "name": "No PDF"
      },
      {
        "parameters": {
          "jsCode": "function pickHeader(headers, name) {\n  if (!headers) return '';\n  if (Array.isArray(headers)) {\n    const h = headers.find(x => (x.name || '').toLowerCase() === name.toLowerCase());\n    return h?.value || '';\n  }\n  return headers[name] || headers[name.toLowerCase()] || headers[name.toUpperCase()] || '';\n}\n\nfunction isPdfFilename(name) {\n  return !!name && String(name).toLowerCase().endsWith('.pdf');\n}\n\n// âœ… Extract PDF URLs, href PDFs, and bare filenames (Workorder.pdf)\nfunction extractPdfLinks(text) {\n  if (!text) return [];\n  const t = String(text);\n  const out = new Set();\n\n  // 1) Real URLs ending .pdf\n  const urlMatches = t.match(/https?:\\/\\/[^\\s\"'<>]+\\.pdf\\b/gi);\n  if (urlMatches) urlMatches.forEach(u => out.add(u));\n\n  // 2) href=\"...pdf\" OR href=\\\"...pdf\\\"\n  const hrefPdfRe = /href\\s*=\\s*(?:\"|\\\\\")([^\"\\\\]+\\.pdf\\b)(?:\"|\\\\\")/gi;\n  let m;\n  while ((m = hrefPdfRe.exec(t)) !== null) {\n    const href = (m[1] || '').trim();\n    if (href) out.add(href);\n  }\n\n  // 3) Bare filename mentions (e.g., Workorder.pdf)\n  const fileMatches = t.match(/\\b[A-Za-z0-9][A-Za-z0-9 _-]{0,80}\\.pdf\\b/gi);\n  if (fileMatches) fileMatches.forEach(f => out.add(String(f).trim()));\n\n  return [...out];\n}\n\n// âœ… Extract ALL URLs (text + href + escaped href)\nfunction extractAllLinks(text) {\n  if (!text) return [];\n  const t = String(text);\n  const out = new Set();\n\n  // 1) Plain URLs in text\n  const urlRe = /https?:\\/\\/[^\\s\"'<>]+/gi;\n  const urls = t.match(urlRe);\n  if (urls) urls.forEach(u => out.add(u));\n\n  // 2) href=\"...\" links\n  const hrefRe = /href\\s*=\\s*[\"']([^\"']+)[\"']/gi;\n  let m;\n  while ((m = hrefRe.exec(t)) !== null) {\n    const href = (m[1] || '').trim();\n    if (href && /^https?:\\/\\//i.test(href)) out.add(href);\n  }\n\n  // 3) escaped href=\\\"...\\\"\n  const hrefEscapedRe = /href\\\\?=\\s*\\\\?\"([^\"\\\\]+)\\\\?\"/gi;\n  while ((m = hrefEscapedRe.exec(t)) !== null) {\n    const href = (m[1] || '').trim();\n    if (href && /^https?:\\/\\//i.test(href)) out.add(href);\n  }\n\n  return [...out];\n}\n\n// âœ… Pick the \"best\" PropertyTree workorder link (single)\nfunction pickWorkOrderUrl(links) {\n  if (!Array.isArray(links) || links.length === 0) return '';\n\n  // Strongest matches first\n  const priority = [\n    /agent\\.propertytree\\.com\\/external\\/api\\/workorder/i,\n    /\\/external\\/api\\/workorder/i,\n    /propertytree/i,\n    /workorder/i,\n  ];\n\n  for (const re of priority) {\n    const hit = links.find(l => re.test(l));\n    if (hit) return hit;\n  }\n\n  return links[0] || '';\n}\n\nfunction findPdfInBinary(binary) {\n  const results = [];\n  if (!binary || typeof binary !== 'object') return results;\n\n  for (const [key, b] of Object.entries(binary)) {\n    const fileName = b?.fileName || b?.file_name || '';\n    const mimeType = b?.mimeType || b?.mime_type || '';\n\n    const isPdf =\n      (mimeType && String(mimeType).toLowerCase() === 'application/pdf') ||\n      isPdfFilename(fileName);\n\n    if (isPdf) {\n      results.push({\n        source: 'binary',\n        binaryKey: key,\n        fileName,\n        mimeType: mimeType || 'application/pdf',\n        fileSize: b?.fileSize || b?.file_size || null,\n      });\n    }\n  }\n\n  return results;\n}\n\nfunction walkParts(parts, out = []) {\n  if (!Array.isArray(parts)) return out;\n  for (const p of parts) {\n    out.push(p);\n    if (p.parts) walkParts(p.parts, out);\n  }\n  return out;\n}\n\nfunction findPdfInPayload(payload) {\n  const results = [];\n  const partsFlat = walkParts(payload?.parts || []);\n\n  for (const p of partsFlat) {\n    const filename = p?.filename || '';\n    const mimeType = p?.mimeType || p?.mime_type || '';\n    const body = p?.body || {};\n    const attachmentId = body?.attachmentId || body?.attachment_id || null;\n\n    const isPdf =\n      (mimeType && String(mimeType).toLowerCase() === 'application/pdf') ||\n      isPdfFilename(filename);\n\n    if (isPdf && (filename || attachmentId)) {\n      results.push({\n        source: 'payload',\n        fileName: filename,\n        mimeType: mimeType || 'application/pdf',\n        attachmentId,\n        size: body?.size ?? null,\n      });\n    }\n  }\n\n  return results;\n}\n\nfunction normalizeFrom(fromRaw) {\n  let name = '';\n  let email = '';\n\n  if (fromRaw && typeof fromRaw === 'object' && Array.isArray(fromRaw.value) && fromRaw.value.length) {\n    const v = fromRaw.value[0] || {};\n    name = String(v.name || '').trim();\n    email = String(v.address || '').trim().toLowerCase();\n  } else {\n    const raw = String(fromRaw || '').trim();\n\n    const angle = raw.match(/<\\s*([^>]+@[^>\\s]+)\\s*>/);\n    if (angle) {\n      email = angle[1].trim().toLowerCase();\n      name = raw.replace(angle[0], '').replace(/\"/g, '').trim();\n    } else {\n      const em = raw.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n      if (em) {\n        email = em[0].trim().toLowerCase();\n        name = raw.replace(em[0], '').replace(/[<>\"()]/g, '').trim();\n      } else {\n        name = raw.replace(/\"/g, '').trim();\n      }\n    }\n  }\n\n  const parts = name.split(/\\s+/).filter(Boolean);\n  const firstName = parts[0] || '';\n  const lastName = parts.length > 1 ? parts.slice(1).join(' ') : '';\n\n  return {\n    senderEmail: email,\n    senderName: name,\n    senderFirstName: firstName,\n    senderLastName: lastName,\n  };\n}\n\nreturn items.map((item, idx) => {\n  const headers = item.json.headers || item.json.payload?.headers || null;\n\n  const subject = item.json.subject || pickHeader(headers, 'Subject');\n  const fromRaw = item.json.from || pickHeader(headers, 'From');\n  const to = item.json.to || pickHeader(headers, 'To');\n  const date = item.json.date || pickHeader(headers, 'Date');\n\n  const emailText =\n    item.json.body ||\n    item.json.textPlain ||\n    item.json.text ||\n    item.json.snippet ||\n    '';\n\n  const emailHtml =\n    item.json.html ||\n    item.json.textHtml ||\n    '';\n\n  const mergeKey =\n    item.json.id ||\n    item.json.messageId ||\n    pickHeader(headers, 'Message-Id') ||\n    `fallback_${idx}`;\n\n  const pdfFromBinary = findPdfInBinary(item.binary);\n  const pdfFromPayload = findPdfInPayload(item.json.payload);\n\n  const pdfAttachments = [...pdfFromBinary, ...pdfFromPayload];\n  const hasPdfAttachment = pdfAttachments.length > 0;\n\n  const combined = `${emailText} ${emailHtml}`;\n\n  // âœ… PDF links + filenames\n  const pdfLinks = extractPdfLinks(combined);\n  const hasPdfLinkOnly = pdfLinks.length > 0 && !hasPdfAttachment;\n\n  // âœ… ALL links (includes href + escaped href)\n  const allLinks = extractAllLinks(combined);\n\n  // âœ… best workorder url (single)\n  const workOrderUrl = pickWorkOrderUrl(allLinks);\n\n  // Sender\n  const sender = normalizeFrom(fromRaw);\n\n  return {\n    json: {\n      mergeKey,\n      mode: hasPdfAttachment\n        ? 'PROCESS_PDF'\n        : (hasPdfLinkOnly || workOrderUrl)\n          ? 'LINK_ONLY'\n          : 'READ_EMAIL_ONLY',\n\n      hasPdfAttachment,\n      hasPdfLinkOnly,\n      pdfAttachments,\n      pdfLinks,\n\n      emailMeta: {\n        id: item.json.id ?? '',\n        threadId: item.json.threadId ?? '',\n        text: item.json.text ?? item.json.textPlain ?? item.json.body ?? item.json.snippet ?? '',\n\n        senderEmail: sender.senderEmail,\n        senderFirstName: sender.senderFirstName,\n        senderLastName: sender.senderLastName,\n        senderName: sender.senderName,\n\n        subject,\n        //from: fromRaw,\n        //to,\n        date,\n        //snippet: item.json.snippet || '',\n        emailText,\n        //emailHtml,\n\n        // âœ… NEW\n        workOrderUrl,\n        //allLinks,\n      },\n    },\n    binary: item.binary,\n  };\n});\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          576,
          240
        ],
        "id": "2658e38a-d7b5-47cc-87d3-731e7fc1d202",
        "name": "Build Email Meta"
      },
      {
        "parameters": {
          "jsCode": "const out = [];\n\nfunction hasPdf(bin) {\n  const b = bin || {};\n  return Object.values(b).some(x => {\n    const mime = (x.mimeType || '').toLowerCase();\n    const name = (x.fileName || '').toLowerCase();\n    return mime.includes('pdf') || name.endsWith('.pdf');\n  });\n}\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n\n  // If it has a PDF, SKIP\n  if (hasPdf(item.binary)) continue;\n\n  const meta = item.json.emailMeta || {};\n  const mergeKey = item.json.mergeKey || `fallback_${i}`;\n\n  out.push({\n    json: {\n      mergeKey,\n      emailMeta: meta,\n\n      // flat fields (so you SEE data in Table)\n      id: meta.id || '',\n      threadId: meta.threadId || '',\n      subject: meta.subject || '',\n      from: meta.from || '',\n      to: meta.to || '',\n      date: meta.date || '',\n      snippet: meta.snippet || '',\n      emailText: meta.emailText || '',\n      emailHtml: meta.emailHtml || '',\n\n      pdfCount: 0,\n      pdfFiles: [],\n      pdfText: '',\n    },\n  });\n}\n\nreturn out;\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -1664,
          1216
        ],
        "id": "e9f994ca-cfb1-48a5-ba65-b8e218623086",
        "name": "Create NO-PDF list from Build Email Meta",
        "disabled": true
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "=You are a data extraction engine.\n\nYour task:\nExtract ONLY missing lead fields from the content below and return a SINGLE JSON OBJECT\nthat EXACTLY matches the required schema.\n\nâš ï¸ OUTPUT RULES (CRITICAL):\n- Output MUST be valid JSON only. No explanations, no markdown, no extra text.\n- ALL fields in the schema MUST be present.\n- If a value is unknown or not found, return an empty string \"\".\n- Do NOT remove, rename, or add fields.\n- Do NOT nest objects or arrays.\n\nHardcoded fields (DO NOT change these values):\n- Timestamp: {{ $json.Timestamp }}\n- Id: {{ $json.Id }}\n- Lead Type: {{ $json['Lead Type'] }}\n- First Name: {{ $json['First Name'] }}\n- Last Name: {{ $json['Last Name'] }}\n- Email Address: {{ $json['Email Address'] }}\n- How they heard about us: {{ $json['How they heard about us'] }}\n- Lead Qualifier: {{ $json['Lead Qualifier'] }}\n\n\nPhone rules:\n- Phone Number must belong to the requestor / agent / body corporate / tenant.\n- Ignore Window Revival phone numbers.\n\nAddress rules:\n- Address = unit + street only.\n- Suburb = locality only.\n- State = Australian abbreviation (e.g. QLD).\n- Postal Code:\n  - Use explicit 4-digit Australian postcode if shown.\n  - If missing but Suburb + State are known, you MAY populate the correct Australian postcode.\n  - Only output valid Australian postcodes.\n\nReferred By rule:\n- \"Referred By\" MUST be the company or organisation requesting the work.\n- Do NOT put a personâ€™s name here unless no company is mentioned.\n\nWork Order / Reference rules:\n- Identify any Work Order Number, Job Number, Quote Number, Reference ID, or Ticket ID.\n- INCLUDE this clearly inside Enquiry under **Invoice / Billing** as:\n  \"Reference / Work Order No: <value>\"\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nENQUIRY RULES â€“ VERY DETAILED SUMMARY\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nEnquiry MUST be a **clear, detailed, multi-line operational summary** built from:\n1) PDF Text (highest priority)\n2) EmailText\n3) Subject (lowest priority)\n\nThe goal:  \nðŸ“Œ A technician, scheduler, or accounts person should fully understand the job\nWITHOUT opening the email or PDF.\n\nFORMAT Enquiry EXACTLY like this (omit any line that has no data):\n\nJob Overview:\n- Job type: <inspection / quote / repair / work order>\n- Issue description: <what is wrong, symptoms, urgency if mentioned>\n- Affected items: <window / door type, location in unit if known>\n- Special notes: <constraints, expectations, deadlines>\n\nProperty Details:\n- Address: <unit + street>\n- Suburb / State / Postcode: <if available>\n- Property type: <unit / apartment / body corporate / commercial if stated>\n\nTenant / Access Information:\n- Tenant name: <if provided>\n- Tenant phone: <if provided>\n- Tenant email: <if provided>\n- Access instructions: <keys, times, contact-before-attending, etc.>\n- Site contact / agent: <name + company if stated>\n\nInvoice / Billing Instructions:\n- Bill to / Quote to: <company or entity>\n- ABN: <if present>\n- Email for invoices/quotes: <if present>\n- Reference / Work Order No: <job / quote / ticket number>\n- Approval required: <committee / manager / none if stated>\n\nKey Operational Details:\n- Required actions: <inspect, quote, repair, report>\n- Deliverables: <quote, photos, report, invoice>\n- Dates mentioned: <issued / due / preferred timeframe>\n- Any other critical instructions not captured above\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nINPUT DATA:\nSubject:\n{{ $json.Subject }}\n\nEmailText:\n{{ $json.EmailText }}\n\nPDF Text:\n{{ $json.pdfText }}\n\n---\n\nRETURN THIS EXACT JSON OBJECT, WITH THE SAME KEYS (INCLUDING THE CURLY APOSTROPHE IN Iâ€™d).\nONLY replace the empty strings \"\" with extracted values when found.\nDo NOT change the hardcoded values.\n\n{\n  \"Timestamp\": \"{{ $json.Timestamp }}\",\n  \"Id\": \"{{ $json.Id }}\",\n  \"Lead Type\": \"{{ $json['Lead Type'] }}\",\n  \"First Name\": \"{{ $json['First Name'] }}\",\n  \"Last Name\": \"{{ $json['Last Name'] }}\",\n  \"Mobile Number\": \"\",\n  \"Phone Number\": \"\",\n  \"Email Address\": \"{{ $json['Email Address'] }}\",\n  \"Address\": \"\",\n  \"State\": \"\",\n  \"Suburb\": \"\",\n  \"Postal Code\": \"\",\n  \"Enquiry\": \"\",\n  \"Quantity\": \"\",\n  \"Iâ€™d Like To Get My Project Underway\": \"\",\n  \"How they heard about us\": \"{{ $json['How they heard about us'] }}\",\n  \"Lead Qualifier\": \"{{ $json['Lead Qualifier'] }}\",\n  \"Referred By\": \"\"\n}",
          "hasOutputParser": true,
          "options": {
            "systemMessage": "You are an AI assistant that extracts structured lead data from emails and PDF text.\nYou must return ONLY valid JSON.\nIf a field is missing, return an empty string.\nDo not guess.\nDo not explain.\n"
          }
        },
        "type": "@n8n/n8n-nodes-langchain.agent",
        "typeVersion": 3.1,
        "position": [
          2656,
          -80
        ],
        "id": "1a6de284-c015-40c1-9c75-158eeff023c2",
        "name": "AI Agent"
      },
      {
        "parameters": {
          "model": {
            "__rl": true,
            "mode": "list",
            "value": "gpt-4.1-mini"
          },
          "responsesApiEnabled": false,
          "options": {}
        },
        "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
        "typeVersion": 1.3,
        "position": [
          2592,
          160
        ],
        "id": "873f4603-7fdf-4ef4-b29c-7fd231531d3b",
        "name": "OpenAI Chat Model",
        "credentials": {
          "openAiApi": {
            "id": "oQQrCQWqdo1CuRzx",
            "name": "WRai: OpenAi account"
          }
        }
      },
      {
        "parameters": {
          "jsCode": "const SPLIT_NODE_NAME = \"Split PDFs (keep meta)\";\n\nconst splitItems = $items(SPLIT_NODE_NAME, 0);\nconst outMap = new Map();\n\nfor (let i = 0; i < items.length; i++) {\n  const extracted = items[i];\n  const meta = splitItems[i]?.json || {};\n\n  const mergeKey = meta.mergeKey;\n  if (!mergeKey) {\n    throw new Error(`Group PDFs: mergeKey missing at index ${i}. Check Split PDFs output.`);\n  }\n\n  if (!outMap.has(mergeKey)) {\n    outMap.set(mergeKey, {\n      json: {\n        mergeKey,\n        pdfCount: 0,\n        pdfFiles: [],\n        pdfText: \"\",\n      },\n    });\n  }\n\n  const agg = outMap.get(mergeKey).json;\n\n  agg.pdfCount += 1;\n  agg.pdfFiles.push({\n    key: meta.pdfKey || \"\",\n    fileName: meta.pdfFileName || \"\",\n    mimeType: meta.pdfMimeType || \"\",\n  });\n\n  const text =\n    extracted.json?.text ??\n    extracted.json?.data ??\n    extracted.json?.content ??\n    extracted.json?.extractedText ??\n    \"\";\n\n  if (String(text).trim()) {\n    agg.pdfText += (agg.pdfText ? \"\\n\\n---\\n\\n\" : \"\");\n    agg.pdfText += `### ${meta.pdfFileName || \"PDF\"}\\n${text}`;\n  }\n}\n\nreturn Array.from(outMap.values());\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -1664,
          768
        ],
        "id": "271d4d98-8bbe-4f27-b08f-946cc6e1ca68",
        "name": "Group the PDF text",
        "disabled": true
      },
      {
        "parameters": {
          "jsCode": "return items.map(item => {\n  item.json.pdfText = item.json.pdfText || \"\";\n  item.json.pdfCount = item.json.pdfCount ?? 0;\n  item.json.pdfFiles = item.json.pdfFiles || [];\n  return item;\n});\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          -1664,
          992
        ],
        "id": "e2235883-c111-4a48-a3ce-0725ae3ae2bc",
        "name": "Normalize pdf fields",
        "disabled": true
      },
      {
        "parameters": {
          "sessionIdType": "customKey",
          "sessionKey": "={{ $json.Id }}",
          "contextWindowLength": "=5"
        },
        "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
        "typeVersion": 1.3,
        "position": [
          2720,
          160
        ],
        "id": "92bc8184-c588-4cf7-a1b2-fbfed08b488b",
        "name": "Simple Memory"
      },
      {
        "parameters": {
          "operation": "getAll",
          "limit": 10,
          "filters": {
            "labelIds": [
              "Label_4464659176251527724"
            ]
          }
        },
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          -1216,
          64
        ],
        "id": "bda13613-66cf-4ab1-8d8f-1b93cd0e093e",
        "name": "Get Facebook Leads",
        "webhookId": "1227c9f0-3973-4cc4-86a8-6a876f1a0a59",
        "credentials": {
          "gmailOAuth2": {
            "id": "Iacb6DlpUsfDqQMK",
            "name": "WR: Gmail Account"
          }
        },
        "disabled": true
      },
      {
        "parameters": {
          "operation": "getAll",
          "limit": 10,
          "filters": {
            "labelIds": [
              "Label_236316694232257385"
            ]
          }
        },
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          -1216,
          -320
        ],
        "id": "f1af5aa8-2e91-4f45-b078-d9176dbf4e53",
        "name": "Get SDR Leads",
        "webhookId": "1227c9f0-3973-4cc4-86a8-6a876f1a0a59",
        "credentials": {
          "gmailOAuth2": {
            "id": "Iacb6DlpUsfDqQMK",
            "name": "WR: Gmail Account"
          }
        },
        "disabled": true
      },
      {
        "parameters": {
          "operation": "getAll",
          "limit": 10,
          "filters": {
            "labelIds": [
              "Label_5972230113927178957"
            ]
          }
        },
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          -1216,
          -128
        ],
        "id": "ec70a488-2dde-4efb-bb5b-b1defc1516b0",
        "name": "Get Winrev.net",
        "webhookId": "1227c9f0-3973-4cc4-86a8-6a876f1a0a59",
        "credentials": {
          "gmailOAuth2": {
            "id": "Iacb6DlpUsfDqQMK",
            "name": "WR: Gmail Account"
          }
        },
        "disabled": true
      },
      {
        "parameters": {
          "operation": "getAll",
          "limit": 10,
          "filters": {
            "labelIds": [
              "Label_8054278402706687750"
            ]
          }
        },
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          -1216,
          256
        ],
        "id": "c8e49191-4b40-4e05-8883-35f3d6f0cd93",
        "name": "Get Email Work Order",
        "webhookId": "1227c9f0-3973-4cc4-86a8-6a876f1a0a59",
        "credentials": {
          "gmailOAuth2": {
            "id": "Iacb6DlpUsfDqQMK",
            "name": "WR: Gmail Account"
          }
        },
        "disabled": true
      },
      {
        "parameters": {
          "conditions": {
            "options": {
              "caseSensitive": true,
              "leftValue": "",
              "typeValidation": "strict",
              "version": 3
            },
            "conditions": [
              {
                "id": "ed3a503c-dacd-42cd-9ac0-ca8374a1da9a",
                "leftValue": "={{ $json.hasPdfAttachment }}",
                "rightValue": false,
                "operator": {
                  "type": "boolean",
                  "operation": "true",
                  "singleValue": true
                }
              },
              {
                "id": "50c2da4e-d770-4f9d-b774-d905b3157327",
                "leftValue": "={{ $json.hasPdfLinkOnly }}",
                "rightValue": false,
                "operator": {
                  "type": "boolean",
                  "operation": "true",
                  "singleValue": true
                }
              }
            ],
            "combinator": "or"
          },
          "options": {}
        },
        "type": "n8n-nodes-base.if",
        "typeVersion": 2.3,
        "position": [
          1024,
          240
        ],
        "id": "53d4534a-3c9d-426b-a4b3-a40ecc8d7f15",
        "name": "Check if there is PDF file"
      },
      {
        "parameters": {
          "jsCode": "// âœ… n8n Code node (Run Once for Each Item)\n// EMAIL-ONLY VERSION (no PDF processing)\n// - Parses AI output OR key:value text\n// - Forces Id from emailMeta/mergeKey if missing\n// - Always generates Brisbane Timestamp \"DD/MM/YYYY, HH:mm:ss\"\n// - Builds Enquiry from email meta + email body ONLY (no PDF sections)\n// - HARD-CODED business fields (Lead Type, How heard, Lead Qualifier)\n\nconst input = $input.item.json ?? {};\n\nconst fields = [\n  \"Timestamp\",\"Id\",\"Lead Type\",\"First Name\",\"Last Name\",\"Mobile Number\",\"Phone Number\",\n  \"Email Address\",\"Address\",\"State\",\"Suburb\",\"Postal Code\",\"Enquiry\",\"Quantity\",\n  \"Iâ€™d Like To Get My Project Underway\",\"How they heard about us\",\"Lead Qualifier\",\"Referred By\"\n];\n\nfunction deepCollectStrings(x, acc = []) {\n  if (x == null) return acc;\n  if (typeof x === \"string\") { const s = x.trim(); if (s) acc.push(s); return acc; }\n  if (Array.isArray(x)) { for (const v of x) deepCollectStrings(v, acc); return acc; }\n  if (typeof x === \"object\") {\n    const preferredKeys = [\"output_text\",\"text\",\"content\",\"message\",\"value\",\"delta\"];\n    for (const k of preferredKeys) if (k in x) deepCollectStrings(x[k], acc);\n    for (const k of Object.keys(x)) if (!preferredKeys.includes(k)) deepCollectStrings(x[k], acc);\n  }\n  return acc;\n}\n\nfunction stripFences(s){\n  return String(s||\"\")\n    .replace(/^```(?:json)?\\s*/i,\"\")\n    .replace(/```$/i,\"\")\n    .trim();\n}\n\nfunction tryParseJson(s){\n  s = stripFences(s); if (!s) return null;\n  try { return JSON.parse(s); } catch {}\n  const a=s.indexOf(\"{\"), b=s.lastIndexOf(\"}\");\n  if (a!==-1 && b!==-1 && b>a) { try { return JSON.parse(s.slice(a,b+1)); } catch {} }\n  const c=s.indexOf(\"[\"), d=s.lastIndexOf(\"]\");\n  if (c!==-1 && d!==-1 && d>c) { try { return JSON.parse(s.slice(c,d+1)); } catch {} }\n  return null;\n}\n\nfunction parseKeyValueLines(text){\n  const obj = {};\n  const lines = String(text||\"\").split(/\\r?\\n/).map(l=>l.trim()).filter(Boolean);\n  for (const line of lines) {\n    const m =\n      line.match(/^\\-?\\s*([^:]+?)\\s*:\\s*(.*)$/) ||\n      line.match(/^\\-?\\s*([^â€“-]+?)\\s*[â€“-]\\s*(.*)$/);\n    if (!m) continue;\n    obj[m[1].trim()] = (m[2]??\"\").trim();\n  }\n  return obj;\n}\n\n// ---------- Timestamp helper (Brisbane) ----------\nfunction brisbaneTimestampNow() {\n  const dtf = new Intl.DateTimeFormat(\"en-AU\", {\n    timeZone: \"Australia/Brisbane\",\n    day: \"2-digit\",\n    month: \"2-digit\",\n    year: \"numeric\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: false,\n  });\n\n  const parts = Object.fromEntries(dtf.formatToParts(new Date()).map(p => [p.type, p.value]));\n  return `${parts.day}/${parts.month}/${parts.year}, ${parts.hour}:${parts.minute}:${parts.second}`;\n}\n\nfunction looksLikeDesiredTimestampFormat(s) {\n  return /^\\d{2}\\/\\d{2}\\/\\d{4}, \\d{2}:\\d{2}:\\d{2}$/.test(String(s || \"\").trim());\n}\n\n// ---------- Enquiry formatting (EMAIL ONLY) ----------\nfunction normalizeNewlines(s) {\n  return String(s || \"\")\n    .replace(/\\r\\n/g, \"\\n\")\n    .replace(/\\r/g, \"\\n\")\n    .replace(/[ \\t]+\\n/g, \"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}\n\nfunction extractSection(text, label) {\n  const t = normalizeNewlines(text);\n  const re = new RegExp(`(^|\\\\n)${label}\\\\s*:\\\\s*`, \"i\");\n  const m = t.match(re);\n  if (!m) return null;\n\n  const startIdx = m.index + m[0].length;\n  const rest = t.slice(startIdx);\n  const stop = rest.search(/\\n(?:Email Subject|From|To|Email Body|Email HTML)\\s*:/i);\n  return (stop === -1 ? rest : rest.slice(0, stop)).trim();\n}\n\nfunction formatEnquiryEmailOnly(enquiryRaw, fallbackEmailMeta) {\n  let s = normalizeNewlines(enquiryRaw);\n\n  if (!s) {\n    const parts = [];\n    if (fallbackEmailMeta?.subject) parts.push(`Email Subject: ${fallbackEmailMeta.subject}`);\n    if (fallbackEmailMeta?.from) parts.push(`From: ${fallbackEmailMeta.from}`);\n    if (fallbackEmailMeta?.to) parts.push(`To: ${fallbackEmailMeta.to}`);\n    if (fallbackEmailMeta?.emailText) parts.push(`Email Body:\\n${fallbackEmailMeta.emailText}`);\n    s = parts.join(\"\\n\\n\");\n  }\n\n  return s;\n}\n\n// 1) Collect raw text\nconst raw = deepCollectStrings(input.output ?? input).join(\"\\n\\n\").trim();\n\n// 2) Parse AI output JSON first, else key/value lines\nlet parsed = tryParseJson(raw);\nif (Array.isArray(parsed)) parsed = parsed[0] ?? null;\nif (!parsed || typeof parsed !== \"object\") parsed = parseKeyValueLines(raw);\n\n// 3) Build output\nconst out = {};\nfor (const f of fields) out[f] = parsed?.[f] ?? \"\";\n\n// âœ… FORCE Id fallback\nconst idFallback =\n  input?.emailMeta?.id ||\n  input?.emailMeta?.threadId ||\n  input?.mergeKey ||\n  input?.id ||\n  input?.threadId ||\n  \"\";\n\nout[\"Id\"] = out[\"Id\"] || idFallback;\n\n// âœ… Timestamp (Brisbane)\nif (!out[\"Timestamp\"] || !looksLikeDesiredTimestampFormat(out[\"Timestamp\"])) {\n  out[\"Timestamp\"] = brisbaneTimestampNow();\n}\n\n// âœ… EMAIL-only Enquiry\nout[\"Enquiry\"] = formatEnquiryEmailOnly(\n  out[\"Enquiry\"],\n  input?.emailMeta || {}\n);\n\n// ================= HARD-CODED BUSINESS RULES =================\nout[\"Lead Type\"] = \"Work Order Lead\";\nout[\"How they heard about us\"] = \"Real Estate Property Managers\";\nout[\"Lead Qualifier\"] = \"Good\";\n// =============================================================\n\nreturn [{ json: out }];\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2368,
          432
        ],
        "id": "107dc6ef-d31b-40e5-8822-89bd58395967",
        "name": "Email only"
      },
      {
        "parameters": {
          "promptType": "define",
          "text": "=You are a data extraction engine.\n\nYour task:\nExtract ONLY missing lead fields and structured job details from the email below.\n\nHardcoded fields (DO NOT change these values):\n- Timestamp: {{ $json.Timestamp }}\n- Id: {{ $json.Id }}\n- Lead Type: {{ $json['Lead Type'] }}\n- How they heard about us: {{ $json['How they heard about us'] }}\n- Lead Qualifier: {{ $json['Lead Qualifier'] }}\n- Referred By: Real Estate Property Managers\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nCRITICAL CONTACT RULES (MANDATORY)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n- \"First Name\" and \"Last Name\" MUST be the EMAIL SENDER / REQUESTOR.\n- For \"Real Estate Property Managers\" leads:\n  - The sender is the PROPERTY MANAGER or AGENCY staff.\n  - Do NOT use tenant/resident name as the lead contact unless the tenant is explicitly the sender.\n- If the sender name is not clearly shown, leave First Name and Last Name blank.\n\nPHONE & EMAIL RULES\n- Phone numbers and email addresses MUST belong to the sender/requestor.\n- Do NOT use tenant, invoice, or third-party phone/email for lead contact fields.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nJOB & REFERENCE EXTRACTION RULES\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nExtract ONLY if explicitly present:\n- Work Order Number\n- Job Order Number\n- Quote Number\n- Reference Codes (e.g. \"T003\")\n- Job Description / Summary / Scope of Works\n- Key / Access notes\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nADDRESS RULES (STRICT)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n- Address = unit + street only.\n- Suburb = locality only.\n- State = Australian abbreviation (e.g. QLD).\n- Postal Code must be a valid Australian 4-digit postcode.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nENQUIRY RULES (VERY IMPORTANT)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n- Enquiry MUST contain line breaks using newline characters.\n- Do NOT write everything on one line.\n- Do NOT use bullet symbols (â€¢, -, *).\n- Use plain text with line breaks only.\n\nENQUIRY FORMAT (EXACT STRUCTURE):\nWork Order / Reference: <value or blank>\nProperty Address: <address, suburb state postcode>\nJob Description: <summary>\nKey / Access Notes: <if any>\n\nIf multiple references exist, choose the most relevant for \"Work Order / Reference\" and include others inside Job Description.\n\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nOUTPUT FORMAT (STRICT JSON ONLY)\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\nReturn ONLY valid JSON.\nALL fields below MUST be present.\nIf a value is unknown or not found, return \"\".\nDo NOT rename fields.\nDo NOT add new fields.\nDo NOT nest objects.\nDo NOT include explanations, markdown, or commentary.\n\n{\n  \"Timestamp\": \"{{ $json.Timestamp }}\",\n  \"Id\": \"{{ $json.Id }}\",\n  \"Lead Type\": \"{{ $json['Lead Type'] }}\",\n  \"First Name\": \"\",\n  \"Last Name\": \"\",\n  \"Mobile Number\": \"\",\n  \"Phone Number\": \"\",\n  \"Email Address\": \"\",\n  \"Address\": \"\",\n  \"State\": \"\",\n  \"Suburb\": \"\",\n  \"Postal Code\": \"\",\n  \"Enquiry\": \"\",\n  \"Quantity\": \"\",\n  \"Iâ€™d Like To Get My Project Underway\": \"\",\n  \"How they heard about us\": \"{{ $json['How they heard about us'] }}\",\n  \"Lead Qualifier\": \"{{ $json['Lead Qualifier'] }}\",\n  \"Referred By\": \"Real Estate Property Managers\"\n}\n\nEmail body:\n{{ $json.Enquiry }}\n",
          "hasOutputParser": true,
          "options": {
            "systemMessage": "You are an AI assistant that extracts structured lead data from emails and PDF text.\nYou must return ONLY valid JSON.\nIf a field is missing, return an empty string.\nDo not guess.\nDo not explain.\n"
          }
        },
        "type": "@n8n/n8n-nodes-langchain.agent",
        "typeVersion": 3.1,
        "position": [
          2656,
          432
        ],
        "id": "13d9ccee-5995-4466-a98a-9e49d4c92caa",
        "name": "AI Agent1"
      },
      {
        "parameters": {
          "model": {
            "__rl": true,
            "mode": "list",
            "value": "gpt-5-mini"
          },
          "responsesApiEnabled": false,
          "options": {}
        },
        "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
        "typeVersion": 1.3,
        "position": [
          2592,
          656
        ],
        "id": "16f1df29-c2c0-414e-a371-2865db006db7",
        "name": "OpenAI Chat Model1",
        "credentials": {
          "openAiApi": {
            "id": "oQQrCQWqdo1CuRzx",
            "name": "WRai: OpenAi account"
          }
        }
      },
      {
        "parameters": {
          "sessionIdType": "customKey",
          "sessionKey": "={{ $('Email only').item.json.Id }}"
        },
        "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
        "typeVersion": 1.3,
        "position": [
          2720,
          656
        ],
        "id": "abe30efd-2f31-4974-a054-7c14f04dcfd9",
        "name": "Simple Memory1"
      },
      {
        "parameters": {
          "jsonSchemaExample": "{\n  \"Timestamp\": \"string\",\n  \"Id\": \"string\",\n  \"Lead Type\": \"string\",\n  \"First Name\": \"string\",\n  \"Last Name\": \"string\",\n  \"Mobile Number\": \"string\",\n  \"Phone Number\": \"string\",\n  \"Email Address\": \"string\",\n  \"Address\": \"string\",\n  \"State\": \"string\",\n  \"Suburb\": \"string\",\n  \"Postal Code\": \"string\",\n  \"Enquiry\": \"string\",\n  \"Quantity\": \"string\",\n  \"Iâ€™d Like To Get My Project Underway\": \"string\",\n  \"How they heard about us\": \"string\",\n  \"Lead Qualifier\": \"string\",\n  \"Referred By\": \"string\"\n}\n"
        },
        "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
        "typeVersion": 1.3,
        "position": [
          2848,
          656
        ],
        "id": "d9f4d98b-1f39-40c3-adae-3b34951974c1",
        "name": "Structured Output Parser"
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "ba2e0e97-f6b8-4ac3-b647-c6f56ea7fff1",
                "name": "Timestamp",
                "value": "={{ $json.Timestamp }}",
                "type": "string"
              },
              {
                "id": "bcdad444-30ec-4813-aa97-d8b6f5116093",
                "name": "Id",
                "value": "={{ $json.Id }}",
                "type": "string"
              },
              {
                "id": "ff7cd238-b935-4ad2-989b-6ad1f8e6789f",
                "name": "Lead Type",
                "value": "={{ $json[\"Lead Type\"] }}",
                "type": "string"
              },
              {
                "id": "57bc231d-9a83-4236-8a70-6d7ea8149127",
                "name": "First Name",
                "value": "={{ $json[\"First Name\"] }}",
                "type": "string"
              },
              {
                "id": "fc8c49e6-6095-411a-9bb4-5579f3eb4887",
                "name": "Last Name",
                "value": "={{ $json[\"Last Name\"] }}",
                "type": "string"
              },
              {
                "id": "deb663a6-0bfb-4896-9f92-723a3295cfb4",
                "name": "Mobile Number",
                "value": "={{ $json[\"Mobile Number\"] }}",
                "type": "string"
              },
              {
                "id": "bdc6140e-39b3-4b44-82a1-fa42ae81ba12",
                "name": "Phone Number",
                "value": "={{ $json[\"Phone Number\"] }}",
                "type": "string"
              },
              {
                "id": "a166fbe7-eb6b-479f-a8b6-38189205c385",
                "name": "Email Address",
                "value": "={{ $json[\"Email Address\"] }}",
                "type": "string"
              },
              {
                "id": "03cf1ca4-f1e1-4d60-9e7d-0d6ed61c8990",
                "name": "Address",
                "value": "={{ $json.Address }}",
                "type": "string"
              },
              {
                "id": "dc4fc907-f341-4443-8c41-0707f8460a93",
                "name": "State",
                "value": "={{ $json.State }}",
                "type": "string"
              },
              {
                "id": "057479b5-8277-4e6f-ae45-fcad076c0ec1",
                "name": "Suburb",
                "value": "={{ $json.Suburb }}",
                "type": "string"
              },
              {
                "id": "4add8b77-b6cb-4f50-a2ba-d82b0941b359",
                "name": "Postal Code",
                "value": "={{ $json[\"Postal Code\"] }}",
                "type": "string"
              },
              {
                "id": "1722ba2a-4b20-4ff8-82a3-307f934c5da2",
                "name": "Enquiry",
                "value": "={{ $json.Enquiry }}",
                "type": "string"
              },
              {
                "id": "ff3b995b-4fca-48c6-bd74-925d888bc8ab",
                "name": "Quantity",
                "value": "={{ $json.Quantity }}",
                "type": "string"
              },
              {
                "id": "56626fe5-134f-4267-8ca0-ec2db595dd7b",
                "name": "Enquiry",
                "value": "={{ $json.Enquiry }}",
                "type": "string"
              },
              {
                "id": "3bba2c17-3b8c-408b-9166-a045b21ef5aa",
                "name": "Quantity",
                "value": "={{ $json.Quantity }}",
                "type": "string"
              },
              {
                "id": "5fdbf2f9-ab3a-4435-8ead-a59a066dcd4b",
                "name": "Iâ€™d Like To Get My Project Underway",
                "value": "={{ $json[\"Iâ€™d Like To Get My Project Underway\"] }}",
                "type": "string"
              },
              {
                "id": "c242e54b-98ed-4384-9dff-0012f078c6ef",
                "name": "How they heard about us",
                "value": "={{ $json[\"How they heard about us\"] }}",
                "type": "string"
              },
              {
                "id": "1f66b97f-eb27-4785-8231-f4f8c3b37a1c",
                "name": "Lead Qualifier",
                "value": "={{ $json[\"Lead Qualifier\"] }}",
                "type": "string"
              },
              {
                "id": "b0afdf1f-b43a-4975-b873-18e452de253d",
                "name": "Referred By",
                "value": "={{ $json[\"Referred By\"] }}",
                "type": "string"
              }
            ]
          },
          "options": {}
        },
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          3280,
          240
        ],
        "id": "7be45353-3120-45a2-8251-0cac1531169d",
        "name": "Work Order Set Fields"
      },
      {
        "parameters": {
          "jsCode": "function toMs(d) {\n  const t = Date.parse(d);\n  return Number.isFinite(t) ? t : Number.POSITIVE_INFINITY;\n}\n\nconst bestByThread = new Map();\n\nfor (const item of items) {\n  const threadId = item.json?.emailMeta?.threadId || item.json?.threadId || item.json?.mergeKey || 'no_thread';\n  const ms = toMs(item.json?.emailMeta?.date);\n\n  const prev = bestByThread.get(threadId);\n  if (!prev) {\n    bestByThread.set(threadId, { item, ms });\n    continue;\n  }\n\n  // âœ… Keep the OLDEST message (origin)\n  if (ms < prev.ms) {\n    bestByThread.set(threadId, { item, ms });\n  }\n}\n\n// Return only origins (one item per thread)\nreturn Array.from(bestByThread.values()).map(x => x.item);\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          800,
          240
        ],
        "id": "46e42b82-b50f-465f-87fd-ec43eaa1048c",
        "name": "filters to origin per thread"
      },
      {
        "parameters": {
          "jsonSchemaExample": "{\n  \"Timestamp\": \"string\",\n  \"Id\": \"string\",\n  \"Lead Type\": \"string\",\n  \"First Name\": \"string\",\n  \"Last Name\": \"string\",\n  \"Mobile Number\": \"string\",\n  \"Phone Number\": \"string\",\n  \"Email Address\": \"string\",\n  \"Address\": \"string\",\n  \"State\": \"string\",\n  \"Suburb\": \"string\",\n  \"Postal Code\": \"string\",\n  \"Enquiry\": \"string\",\n  \"Quantity\": \"string\",\n  \"Iâ€™d Like To Get My Project Underway\": \"string\",\n  \"How they heard about us\": \"string\",\n  \"Lead Qualifier\": \"string\",\n  \"Referred By\": \"string\"\n}\n"
        },
        "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
        "typeVersion": 1.3,
        "position": [
          2848,
          160
        ],
        "id": "e759ec12-4d36-4cab-9578-e3d69ddd4b1f",
        "name": "Structured Output Parser1"
      },
      {
        "parameters": {
          "operation": "getAll",
          "limit": 10,
          "filters": {
            "labelIds": []
          }
        },
        "type": "n8n-nodes-base.gmail",
        "typeVersion": 2.1,
        "position": [
          -1216,
          -512
        ],
        "id": "8134cd75-6412-482a-9a5c-21441549d4fe",
        "name": "Get Emails",
        "webhookId": "1227c9f0-3973-4cc4-86a8-6a876f1a0a59",
        "credentials": {
          "gmailOAuth2": {
            "id": "Iacb6DlpUsfDqQMK",
            "name": "WR: Gmail Account"
          }
        }
      },
      {
        "parameters": {
          "operation": "rowNotExists",
          "dataTableId": {
            "__rl": true,
            "value": "xP2ggRHskNpdbivo",
            "mode": "list",
            "cachedResultName": "email_threads",
            "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
          },
          "filters": {
            "conditions": [
              {
                "keyName": "threadId",
                "keyValue": "={{ $json.threadId }}"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.dataTable",
        "typeVersion": 1.1,
        "position": [
          2720,
          -688
        ],
        "id": "2c3a6c9c-cbcb-4590-9e94-870e77b06962",
        "name": "SDR - Check if threadId is exists otherwise create"
      },
      {
        "parameters": {
          "operation": "rowNotExists",
          "dataTableId": {
            "__rl": true,
            "value": "xP2ggRHskNpdbivo",
            "mode": "list",
            "cachedResultName": "email_threads",
            "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
          },
          "filters": {
            "conditions": [
              {
                "keyName": "threadId",
                "keyValue": "={{ $json.threadId }}"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.dataTable",
        "typeVersion": 1.1,
        "position": [
          2720,
          -304
        ],
        "id": "19154eae-8007-4dfc-bd38-eabcb167b6aa",
        "name": "FB - Check if threadId is exists otherwise create"
      },
      {
        "parameters": {
          "dataTableId": {
            "__rl": true,
            "value": "xP2ggRHskNpdbivo",
            "mode": "list",
            "cachedResultName": "email_threads",
            "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
          },
          "columns": {
            "mappingMode": "defineBelow",
            "value": {
              "threadId": "={{ $json.Id }}"
            },
            "matchingColumns": [
              "threadId"
            ],
            "schema": [
              {
                "id": "threadId",
                "displayName": "threadId",
                "required": false,
                "defaultMatch": false,
                "display": true,
                "type": "string",
                "readOnly": false,
                "removed": false
              }
            ],
            "attemptToConvertTypes": false,
            "convertFieldsToString": false
          },
          "options": {}
        },
        "type": "n8n-nodes-base.dataTable",
        "typeVersion": 1.1,
        "position": [
          4176,
          64
        ],
        "id": "ba76aa92-5d1d-4c5f-bdb2-b33f8d2c6610",
        "name": "Insert row for ThreadId"
      },
      {
        "parameters": {
          "operation": "rowNotExists",
          "dataTableId": {
            "__rl": true,
            "value": "xP2ggRHskNpdbivo",
            "mode": "list",
            "cachedResultName": "email_threads",
            "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
          },
          "filters": {
            "conditions": [
              {
                "keyName": "threadId",
                "keyValue": "={{ $json.threadId }}"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.dataTable",
        "typeVersion": 1.1,
        "position": [
          2720,
          -496
        ],
        "id": "2ce30bb9-2418-41a5-a65d-b2a8230a3088",
        "name": "WRnet - Check if threadId is exists otherwise create1"
      },
      {
        "parameters": {
          "rules": {
            "values": [
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "leftValue": "={{ $json.hasPdfAttachment }}",
                      "rightValue": false,
                      "operator": {
                        "type": "boolean",
                        "operation": "true",
                        "singleValue": true
                      },
                      "id": "e2336aaa-155d-4b4b-ab79-1fad0bbef319"
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "PDF"
              },
              {
                "conditions": {
                  "options": {
                    "caseSensitive": true,
                    "leftValue": "",
                    "typeValidation": "strict",
                    "version": 3
                  },
                  "conditions": [
                    {
                      "id": "4e1a9157-1cfc-421d-94a1-c9ea9c852225",
                      "leftValue": "={{ $json.hasPdfLinkOnly }}",
                      "rightValue": false,
                      "operator": {
                        "type": "boolean",
                        "operation": "true",
                        "singleValue": true
                      }
                    }
                  ],
                  "combinator": "and"
                },
                "renameOutput": true,
                "outputKey": "Link"
              }
            ]
          },
          "options": {}
        },
        "type": "n8n-nodes-base.switch",
        "typeVersion": 3.4,
        "position": [
          1248,
          32
        ],
        "id": "122ef472-6f09-4e48-8540-45796ea74372",
        "name": "Switch"
      },
      {
        "parameters": {
          "url": "={{ $json.emailMeta.workOrderUrl }}",
          "options": {
            "response": {
              "response": {
                "responseFormat": "file"
              }
            }
          }
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.4,
        "position": [
          1696,
          160
        ],
        "id": "d06d1449-3134-421f-b7a6-335b867d82f7",
        "name": "Download PDF file from Link"
      },
      {
        "parameters": {
          "operation": "pdf",
          "options": {}
        },
        "type": "n8n-nodes-base.extractFromFile",
        "typeVersion": 1.1,
        "position": [
          1920,
          160
        ],
        "id": "5fe5e8f7-1e21-4020-a698-9f9b5b3b9bb6",
        "name": "HTTP Request â†’ Read Binary File â†’ Extract Text"
      },
      {
        "parameters": {
          "operation": "pdf",
          "options": {}
        },
        "type": "n8n-nodes-base.extractFromFile",
        "typeVersion": 1.1,
        "position": [
          1920,
          -64
        ],
        "id": "6b197a5f-e7a9-46af-aadf-331cb3eea0f1",
        "name": "PDF File â†’ Extract Text"
      },
      {
        "parameters": {
          "jsCode": "const out = [];\n\nfor (const item of items) {\n  const mergeKey = item.json.mergeKey;\n\n  if (!mergeKey) {\n    throw new Error(\n      \"Split PDFs: mergeKey missing. Ensure this node receives output from 'Build Email Meta' and no node in between overwrites json.\"\n    );\n  }\n\n  // 1) Handle binary PDFs (attachments)\n  const bin = item.binary || {};\n  for (const key of Object.keys(bin)) {\n    const b = bin[key];\n    if (!b) continue;\n\n    const fileName = (b.fileName || \"\").toLowerCase();\n    const mime = (b.mimeType || \"\").toLowerCase();\n    const isPdf =\n      mime === \"application/pdf\" || mime.includes(\"pdf\") || fileName.endsWith(\".pdf\");\n    if (!isPdf) continue;\n\n    out.push({\n      json: {\n        // keep meta\n        mergeKey,\n        emailMeta: item.json.emailMeta,\n        mode: item.json.mode,\n\n        // pdf meta\n        source: \"binary\",\n        pdfKey: key,\n        pdfFileName: b.fileName || \"\",\n        pdfMimeType: b.mimeType || \"\",\n      },\n      binary: {\n        data: b,\n      },\n    });\n  }\n\n  // 2) Handle LINK_ONLY PDFs (no binary present)\n  const pdfLinks = Array.isArray(item.json.pdfLinks) ? item.json.pdfLinks : [];\n  const workOrderUrl = item.json.emailMeta?.workOrderUrl || item.json.workOrderUrl || \"\";\n\n  for (const name of pdfLinks) {\n    // If the email provides a real URL to download (workOrderUrl), carry it forward\n    // so the next node (HTTP Request) can download the PDF.\n    out.push({\n      json: {\n        mergeKey,\n        emailMeta: item.json.emailMeta,\n        mode: item.json.mode,\n\n        source: \"link_only\",\n        pdfFileName: name || \"\",\n        pdfUrl: workOrderUrl, // <- this is the important bit for downstream download\n      },\n    });\n  }\n}\n\nreturn out;\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1472,
          160
        ],
        "id": "b250c5e0-59fb-4f5b-92ba-2ecc47206378",
        "name": "Link with metadata preserved"
      },
      {
        "parameters": {
          "jsCode": "// âœ… Code node\n// Pull emailMeta from: $('Link with metadata preserved').first().json.emailMeta\n// Use senderName for First / Last Name\n// Use senderEmail for Email Address\n// Add Brisbane Timestamp\n// pdfText comes from: $input.first().json.text\n// Preserve binary\n\nconst em = $('Link with metadata preserved').first()?.json?.emailMeta || {};\n\n// ---------- Brisbane timestamp helper ----------\nfunction brisbaneTimestampNow() {\n  const dtf = new Intl.DateTimeFormat('en-AU', {\n    timeZone: 'Australia/Brisbane',\n    day: '2-digit',\n    month: '2-digit',\n    year: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n\n  const parts = Object.fromEntries(\n    dtf.formatToParts(new Date()).map(p => [p.type, p.value])\n  );\n\n  return `${parts.day}/${parts.month}/${parts.year}, ${parts.hour}:${parts.minute}:${parts.second}`;\n}\n\n// ---------- Split senderName ----------\nfunction splitName(name) {\n  if (!name || typeof name !== 'string') {\n    return { firstName: '', lastName: '' };\n  }\n\n  const parts = name.trim().split(/\\s+/);\n  return {\n    firstName: parts[0] || '',\n    lastName: parts.slice(1).join(' ') || ''\n  };\n}\n\nconst nameParts = splitName(em.senderName);\nconst senderEmail = em.senderEmail ?? '';\n\n// âœ… pdf text shared across all items\nconst pdfText = $input.first()?.json?.text ?? '';\n\nreturn items.map(item => ({\n  json: {\n    // âœ… Timestamp\n    Timestamp: brisbaneTimestampNow(),\n\n    // âœ… Email basics\n    Id: em.id ?? '',\n    Subject: em.subject ?? '',\n    EmailText: em.emailText ?? (em.text ?? ''),\n\n    // âœ… Sender â†’ Lead identity\n    'First Name': nameParts.firstName,\n    'Last Name': nameParts.lastName,\n    'Email Address': senderEmail,\n\n    // âœ… Hard-coded lead fields\n    'Lead Type': 'Work Order Lead',\n    'How they heard about us': 'Real Estate Property Managers',\n    'Lead Qualifier': 'Good',\n\n    // âœ… PDF text (from OCR / extraction node)\n    pdfText\n  },\n\n  // âœ… Preserve binary\n  binary: item.binary\n}));\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2144,
          160
        ],
        "id": "2f1ac898-8ec2-445b-8cda-9dffe59ab829",
        "name": "Merge Link data and email Meta"
      },
      {
        "parameters": {
          "assignments": {
            "assignments": [
              {
                "id": "a03a6e96-2e87-4b93-97d9-c960604be4bf",
                "name": "Timestamp",
                "value": "={{ $json.Timestamp }}",
                "type": "string"
              },
              {
                "id": "c8705047-a421-45e6-96a8-63e0b0c90587",
                "name": "Id",
                "value": "={{ $json.Id }}",
                "type": "string"
              },
              {
                "id": "0da2dd82-fdbf-4e91-b9ad-a54177815b16",
                "name": "Lead Type",
                "value": "={{ $json[\"Lead Type\"] }}",
                "type": "string"
              },
              {
                "id": "90923e2d-7523-40a7-b0e4-a75963e75a4a",
                "name": "First Name",
                "value": "={{ $json['First Name'] }}",
                "type": "string"
              },
              {
                "id": "3d3bf238-8488-4738-8a79-53f59c4c2a63",
                "name": "Last Name",
                "value": "={{ $json['Last Name'] }}",
                "type": "string"
              },
              {
                "id": "53e843da-387b-4508-9b67-037455dcfdfc",
                "name": "Email Address",
                "value": "={{ $json[\"Email Address\"] }}",
                "type": "string"
              },
              {
                "id": "dc41282e-d74c-4463-8cf0-ae449a564717",
                "name": "How they heard about us",
                "value": "={{ $json[\"How they heard about us\"] }}",
                "type": "string"
              },
              {
                "id": "097ebaca-c780-419a-b8c7-09c3c8a171ab",
                "name": "Lead Qualifier",
                "value": "={{ $json[\"Lead Qualifier\"] }}",
                "type": "string"
              },
              {
                "id": "93ad8908-b286-4858-bb30-27d42ff26213",
                "name": "Subject",
                "value": "={{ $json.Subject }}",
                "type": "string"
              },
              {
                "id": "0b42f440-fc55-4030-af8e-2311c47f9968",
                "name": "EmailText",
                "value": "={{ $json.EmailText }}",
                "type": "string"
              },
              {
                "id": "1c7b69a6-ff4c-42d2-b842-c8c4fee8fb25",
                "name": "pdfText",
                "value": "={{ $json.pdfText }}",
                "type": "string"
              }
            ]
          },
          "options": {}
        },
        "type": "n8n-nodes-base.set",
        "typeVersion": 3.4,
        "position": [
          2368,
          32
        ],
        "id": "a0b56f43-92fa-47ec-b005-b71c8c675eea",
        "name": "Set Work Order Fields"
      },
      {
        "parameters": {
          "jsCode": "const out = [];\n\nfor (const item of items) {\n  const j = item.json || {};\n  const mergeKey = j.mergeKey;\n\n  if (!mergeKey) {\n    throw new Error(\n      \"Split PDFs: mergeKey missing. Ensure this node receives output from 'Build Email Meta' and no node in between overwrites json.\"\n    );\n  }\n\n  const emailMeta = { ...(j.emailMeta || {}) };\n  delete emailMeta.workOrderUrl;\n\n  const bin = item.binary || {};\n  const keys = Object.keys(bin);\n\n  for (const key of keys) {\n    const b = bin[key];\n    if (!b) continue;\n\n    const fileName = (b.fileName || \"\").toLowerCase();\n    const mime = (b.mimeType || \"\").toLowerCase();\n    const isPdf =\n      mime === \"application/pdf\" ||\n      mime.includes(\"pdf\") ||\n      fileName.endsWith(\".pdf\");\n\n    if (!isPdf) continue;\n\n    out.push({\n      json: {\n        mergeKey,\n        emailMeta,\n        pdfKey: key,\n        pdfFileName: b.fileName || \"\",\n        pdfMimeType: b.mimeType || \"\",\n      },\n      binary: {\n        // âœ… only one binary key so it won't duplicate\n        data: b,\n      },\n    });\n  }\n}\n\nreturn out;\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1696,
          -64
        ],
        "id": "1a6e9295-7081-422f-a66f-122ca67349cd",
        "name": "PDF attached with metadata preserved"
      },
      {
        "parameters": {
          "jsCode": "// ONE STEP after Extract Text:\n// - Extract Text output: item.json.text\n// - Original meta from: $('PDF attached with metadata preserved').all()[i].json.emailMeta\n// Output: flat fields + PDFText + Lead fields + Brisbane Timestamp\n// Removes: ThreadId, EmailDate\n\nfunction brisbaneTimestampNow() {\n  const dtf = new Intl.DateTimeFormat('en-AU', {\n    timeZone: 'Australia/Brisbane',\n    day: '2-digit',\n    month: '2-digit',\n    year: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n\n  const parts = Object.fromEntries(\n    dtf.formatToParts(new Date()).map(p => [p.type, p.value])\n  );\n\n  // Example format: 10/02/2026, 10:46:25\n  return `${parts.day}/${parts.month}/${parts.year}, ${parts.hour}:${parts.minute}:${parts.second}`;\n}\n\nconst originals = $('PDF attached with metadata preserved').all();\n\nif (originals.length !== items.length) {\n  throw new Error(`Count mismatch: originals=${originals.length} extracted=${items.length}`);\n}\n\nreturn items.map((extractedItem, i) => {\n  const ex = extractedItem.json || {};\n  const orig = originals[i].json || {};\n  const em = orig.emailMeta || {};\n\n  return {\n    json: {\n      // âœ… Timestamp (Brisbane)\n      Timestamp: brisbaneTimestampNow(),\n\n      // âœ… Exploded email fields\n      Id: em.id ?? '',\n      Subject: em.subject ?? '',\n      //SenderName: em.senderName ?? '',\n      'First Name': em.senderFirstName ?? '',\n      'Last Name': em.senderLastName ?? '',\n      'Email Address': em.senderEmail ?? '',\n      EmailText: em.emailText ?? em.text ?? '',\n\n      // âœ… PDF text from Extract Text node\n      pdfText: ex.text ?? '',\n\n      // âœ… Lead fields\n      'Lead Qualifier': 'Good',\n      'How they heard about us': 'Real Estate Property Managers',\n      'Lead Type': 'Work Order Lead',\n    }\n  };\n});\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2144,
          -64
        ],
        "id": "43a2d2e1-5d50-49ef-aced-6dcd65a2a17a",
        "name": "Merge PDF and Email Meta"
      },
      {
        "parameters": {
          "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output ?? item.json\n  };\n});\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3056,
          32
        ],
        "id": "7cf67082-ee50-4c21-9f65-662957ee3f6c",
        "name": "PDF Unwrapped Output "
      },
      {
        "parameters": {
          "jsCode": "return items.map(item => {\n  return {\n    json: item.json.output ?? item.json\n  };\n});\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          3056,
          432
        ],
        "id": "e3761740-da03-4615-a09f-9efbcd74cc77",
        "name": "Email Unwrapped Output"
      },
      {
        "parameters": {
          "operation": "rowNotExists",
          "dataTableId": {
            "__rl": true,
            "value": "xP2ggRHskNpdbivo",
            "mode": "list",
            "cachedResultName": "email_threads",
            "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
          },
          "filters": {
            "conditions": [
              {
                "keyName": "threadId",
                "keyValue": "={{ $json.threadId }}"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.dataTable",
        "typeVersion": 1.1,
        "position": [
          352,
          240
        ],
        "id": "b07361ba-7857-484f-9bb4-30908b6f838c",
        "name": "Work Order - Check if threadId is exists otherwise create1"
      },
      {
        "parameters": {
          "operation": "rowNotExists",
          "dataTableId": {
            "__rl": true,
            "value": "xP2ggRHskNpdbivo",
            "mode": "list",
            "cachedResultName": "email_threads",
            "cachedResultUrl": "/projects/6TsYTzg0HY92xH2K/datatables/xP2ggRHskNpdbivo"
          },
          "filters": {
            "conditions": [
              {
                "keyName": "threadId",
                "keyValue": "={{ $json.threadId }}"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.dataTable",
        "typeVersion": 1.1,
        "position": [
          352,
          -160
        ],
        "id": "c5986479-3320-469b-994b-0fd168b7347a",
        "name": "Work Order - Check if threadId is exists otherwise create"
      },
      {
        "parameters": {
          "jsCode": "// Code node (Run once for each item)\n// Creates: Timestamp (Brisbane), Id, Subject, EmailText, First Name, Last Name, Email Address\n// Tries multiple common paths for fields from Gmail/IMAP outputs.\n\nfunction brisbaneTimestampNow() {\n  const dtf = new Intl.DateTimeFormat('en-AU', {\n    timeZone: 'Australia/Brisbane',\n    day: '2-digit',\n    month: '2-digit',\n    year: 'numeric',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n  });\n\n  const parts = Object.fromEntries(\n    dtf.formatToParts(new Date()).map(p => [p.type, p.value])\n  );\n\n  // e.g. 10/02/2026, 10:46:25\n  return `${parts.day}/${parts.month}/${parts.year}, ${parts.hour}:${parts.minute}:${parts.second}`;\n}\n\nfunction parseFromField(fromVal) {\n  if (!fromVal) return { firstName: '', lastName: '', email: '' };\n\n  let text = '';\n  if (typeof fromVal === 'string') text = fromVal;\n  else if (typeof fromVal === 'object') text = fromVal.text || fromVal.value || '';\n\n  // \"Name Here\" <email@domain.com>\n  const match = text.match(/\"?([^\"<]+?)\"?\\s*<([^>]+)>/);\n  if (match) {\n    const name = match[1].trim();\n    const email = match[2].trim();\n    const parts = name.split(/\\s+/);\n    return {\n      firstName: parts[0] || '',\n      lastName: parts.slice(1).join(' ') || '',\n      email,\n    };\n  }\n\n  // email only\n  const emailOnly = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n  return { firstName: '', lastName: '', email: emailOnly ? emailOnly[0] : '' };\n}\n\nreturn items.map(item => {\n  const j = item.json || {};\n\n  // Try common locations for fields\n  const id =\n    j.id ??\n    j.messageId ??\n    j.message?.id ??\n    j.emailMeta?.id ??\n    '';\n\n  const subject =\n    j.subject ??\n    j.Subject ??\n    j.emailMeta?.subject ??\n    '';\n\n  const emailText =\n    j.text ??\n    j.EmailText ??\n    j.emailText ??\n    j.snippet ??\n    j.body ??\n    j.emailMeta?.text ??\n    j.emailMeta?.emailText ??\n    '';\n\n  // \"from\" can be string or object depending on node\n  const fromRaw =\n    j.from ??\n    j.From ??\n    j.sender ??\n    j.senderEmail ?? // sometimes only email\n    j.emailMeta?.from ??\n    j.emailMeta?.senderEmail ??\n    '';\n\n  // If we only have senderEmail but also have senderName, build a proper From string\n  const senderName = j.senderName ?? j.emailMeta?.senderName ?? '';\n  const senderEmail = j.senderEmail ?? j.emailMeta?.senderEmail ?? '';\n  const effectiveFrom =\n    (senderName && senderEmail) ? `${senderName} <${senderEmail}>` : fromRaw;\n\n  const parsedFrom = parseFromField(effectiveFrom);\n\n  return {\n    json: {\n      Timestamp: brisbaneTimestampNow(),\n      Id: String(id),\n      Subject: String(subject),\n      EmailText: String(emailText),\n\n      'First Name': parsedFrom.firstName,\n      'Last Name': parsedFrom.lastName,\n      'Email Address': parsedFrom.email || senderEmail || '',\n    },\n    binary: item.binary,\n  };\n});\n"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          576,
          -160
        ],
        "id": "3059c0d1-ed8d-47f3-8d35-b2b0ea640864",
        "name": "Email only1"
      },
      {
        "parameters": {
          "site": {
            "__rl": true,
            "mode": "list",
            "value": ""
          },
          "requestOptions": {}
        },
        "type": "n8n-nodes-base.microsoftSharePointTool",
        "typeVersion": 1,
        "position": [
          0,
          0
        ],
        "id": "eddd7dfe-67cf-4e0b-8d20-1f738be34278",
        "name": "Download file in Microsoft SharePoint"
      }
    ],
    "connections": {
      "Append row in sheet": {
        "main": [
          [
            {
              "node": "If",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "If": {
        "main": [
          [
            {
              "node": "Send to Wrapp",
              "type": "main",
              "index": 0
            },
            {
              "node": "Wait",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Check id if exist before deleting",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "FB Parsing": {
        "main": [
          [
            {
              "node": "Append row in sheet",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Windowrevival.NET Parsing": {
        "main": [
          [
            {
              "node": "Append row in sheet",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "SDR Parsing": {
        "main": [
          [
            {
              "node": "Append row in sheet",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Delete spam email": {
        "main": [
          []
        ]
      },
      "Check id if exist before deleting": {
        "main": [
          [
            {
              "node": "Get Ids",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Ids": {
        "main": [
          [
            {
              "node": "Delete spam email",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Send a message": {
        "main": [
          []
        ]
      },
      "Wait": {
        "main": [
          [
            {
              "node": "Send a message",
              "type": "main",
              "index": 0
            },
            {
              "node": "Add label to message",
              "type": "main",
              "index": 0
            },
            {
              "node": "Insert row for ThreadId",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Trigger every 5 minute": {
        "main": [
          [
            {
              "node": "Wait1",
              "type": "main",
              "index": 0
            },
            {
              "node": "Get many labels",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait1": {
        "main": [
          [
            {
              "node": "Get Facebook Leads",
              "type": "main",
              "index": 0
            },
            {
              "node": "Get SDR Leads",
              "type": "main",
              "index": 0
            },
            {
              "node": "Get Winrev.net",
              "type": "main",
              "index": 0
            },
            {
              "node": "Get Email Work Order",
              "type": "main",
              "index": 0
            },
            {
              "node": "Get Emails",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Wait2": {
        "main": [
          [
            {
              "node": "Get a message",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Split Emails": {
        "main": [
          [
            {
              "node": "Wait2",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get a message": {
        "main": [
          [
            {
              "node": "Ensure no label \"Label_169\" or Processed by n8n pass",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Ensure no label \"Label_169\" or Processed by n8n pass": {
        "main": [
          [
            {
              "node": "Preserve attachments",
              "type": "main",
              "index": 0
            }
          ],
          []
        ]
      },
      "Router": {
        "main": [
          [
            {
              "node": "SDR - Check if threadId is exists otherwise create",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "WRnet - Check if threadId is exists otherwise create1",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "FB - Check if threadId is exists otherwise create",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Work Order - Check if threadId is exists otherwise create",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Work Order - Check if threadId is exists otherwise create1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Id and Text for SDR": {
        "main": [
          [
            {
              "node": "SDR Parsing",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Id and Text for Windowrevival.NET": {
        "main": [
          [
            {
              "node": "Windowrevival.NET Parsing",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Id and Text for Facebook": {
        "main": [
          [
            {
              "node": "FB Parsing",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Preserve attachments": {
        "main": [
          [
            {
              "node": "Router",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Has PDF?": {
        "main": [
          [],
          []
        ]
      },
      "Extract PDF text": {
        "main": [
          []
        ]
      },
      "Get email meta for WorkOrder/QuoteOrder": {
        "main": [
          []
        ]
      },
      "No PDF": {
        "main": [
          []
        ]
      },
      "Build Email Meta": {
        "main": [
          [
            {
              "node": "filters to origin per thread",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Create NO-PDF list from Build Email Meta": {
        "main": [
          []
        ]
      },
      "OpenAI Chat Model": {
        "ai_languageModel": [
          [
            {
              "node": "AI Agent",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      },
      "AI Agent": {
        "main": [
          [
            {
              "node": "PDF Unwrapped Output ",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Group the PDF text": {
        "main": [
          []
        ]
      },
      "Normalize pdf fields": {
        "main": [
          []
        ]
      },
      "Simple Memory": {
        "ai_memory": [
          [
            {
              "node": "AI Agent",
              "type": "ai_memory",
              "index": 0
            }
          ]
        ]
      },
      "Get Facebook Leads": {
        "main": [
          [
            {
              "node": "Split Emails",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get SDR Leads": {
        "main": [
          [
            {
              "node": "Split Emails",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Winrev.net": {
        "main": [
          [
            {
              "node": "Split Emails",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Get Email Work Order": {
        "main": [
          [
            {
              "node": "Split Emails",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Check if there is PDF file": {
        "main": [
          [
            {
              "node": "Switch",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Email only",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Email only": {
        "main": [
          [
            {
              "node": "AI Agent1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "OpenAI Chat Model1": {
        "ai_languageModel": [
          [
            {
              "node": "AI Agent1",
              "type": "ai_languageModel",
              "index": 0
            }
          ]
        ]
      },
      "Simple Memory1": {
        "ai_memory": [
          [
            {
              "node": "AI Agent1",
              "type": "ai_memory",
              "index": 0
            }
          ]
        ]
      },
      "Structured Output Parser": {
        "ai_outputParser": [
          [
            {
              "node": "AI Agent1",
              "type": "ai_outputParser",
              "index": 0
            }
          ]
        ]
      },
      "AI Agent1": {
        "main": [
          [
            {
              "node": "Email Unwrapped Output",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Work Order Set Fields": {
        "main": [
          [
            {
              "node": "Append row in sheet",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "filters to origin per thread": {
        "main": [
          [
            {
              "node": "Check if there is PDF file",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Structured Output Parser1": {
        "ai_outputParser": [
          [
            {
              "node": "AI Agent",
              "type": "ai_outputParser",
              "index": 0
            }
          ]
        ]
      },
      "Get many labels": {
        "main": [
          []
        ]
      },
      "Get Emails": {
        "main": [
          [
            {
              "node": "Split Emails",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "FB - Check if threadId is exists otherwise create": {
        "main": [
          [
            {
              "node": "Get Id and Text for Facebook",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "SDR - Check if threadId is exists otherwise create": {
        "main": [
          [
            {
              "node": "Get Id and Text for SDR",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Insert row for ThreadId": {
        "main": [
          []
        ]
      },
      "WRnet - Check if threadId is exists otherwise create1": {
        "main": [
          [
            {
              "node": "Get Id and Text for Windowrevival.NET",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Switch": {
        "main": [
          [
            {
              "node": "PDF attached with metadata preserved",
              "type": "main",
              "index": 0
            }
          ],
          [
            {
              "node": "Link with metadata preserved",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Download PDF file from Link": {
        "main": [
          [
            {
              "node": "HTTP Request â†’ Read Binary File â†’ Extract Text",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "PDF File â†’ Extract Text": {
        "main": [
          [
            {
              "node": "Merge PDF and Email Meta",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Link with metadata preserved": {
        "main": [
          [
            {
              "node": "Download PDF file from Link",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "HTTP Request â†’ Read Binary File â†’ Extract Text": {
        "main": [
          [
            {
              "node": "Merge Link data and email Meta",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge Link data and email Meta": {
        "main": [
          [
            {
              "node": "Set Work Order Fields",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "PDF attached with metadata preserved": {
        "main": [
          [
            {
              "node": "PDF File â†’ Extract Text",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Merge PDF and Email Meta": {
        "main": [
          [
            {
              "node": "Set Work Order Fields",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Set Work Order Fields": {
        "main": [
          [
            {
              "node": "AI Agent",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "PDF Unwrapped Output ": {
        "main": [
          [
            {
              "node": "Work Order Set Fields",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Email Unwrapped Output": {
        "main": [
          [
            {
              "node": "Work Order Set Fields",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Work Order - Check if threadId is exists otherwise create1": {
        "main": [
          [
            {
              "node": "Build Email Meta",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Work Order - Check if threadId is exists otherwise create": {
        "main": [
          [
            {
              "node": "Email only1",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "authors": "Christine Kam",
    "name": "Version e6b71c8b",
    "description": "",
    "autosaved": true,
    "workflowPublishHistory": [
      {
        "createdAt": "2026-02-11T00:20:10.350Z",
        "id": 146,
        "workflowId": "NXvUDPpKfGxWETqO",
        "versionId": "e6b71c8b-7839-40bb-9246-cf6881764104",
        "event": "activated",
        "userId": "bc31a112-3ed8-48ca-b94c-7225571c3d7b"
      }
    ]
  }
}