{
  "updatedAt": "2026-01-27T00:35:03.024Z",
  "createdAt": "2026-01-18T11:08:16.553Z",
  "id": "F5Apqb3pbE0Lcfby",
  "name": "02. Email Lead Managment v3",
  "description": null,
  "active": false,
  "isArchived": false,
  "nodes": [
    {
      "parameters": {
        "operation": "append",
        "documentId": {
          "__rl": true,
          "value": "13lFnQiBUmo1W0oQoTNlcn94ouflhuRWlMYu9NQV7taQ",
          "mode": "list",
          "cachedResultName": "Leads Logs",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/13lFnQiBUmo1W0oQoTNlcn94ouflhuRWlMYu9NQV7taQ/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": "gid=0",
          "mode": "list",
          "cachedResultName": "raw",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/13lFnQiBUmo1W0oQoTNlcn94ouflhuRWlMYu9NQV7taQ/edit#gid=0"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "Timestamp": "={{ $json.Timestamp }}",
            "Id": "={{ $json.Id }}",
            "Lead Type": "={{ $json['Lead Type'] }}",
            "First Name": "={{ $json['First Name'] }}",
            "Last Name": "={{ $json['Last Name'] }}",
            "Mobile Number": "={{ $json['Mobile Number'] }}",
            "Phone Number": "={{ $json['Phone Number'] }}",
            "Email Address": "={{ $json['Email Address'] }}",
            "Address": "={{ $json.Address }}",
            "State": "={{ $json.State }}",
            "Suburb": "={{ $json.Suburb }}",
            "Postal Code": "={{ $json['Postal Code'] }}",
            "Enquiry": "={{ $json.Enquiry }}",
            "Quantity": "={{ $json.Quantity }}",
            "I’d Like To Get My Project Underway": "={{ $json['I\\'d Like To Get My Project Underway'] }}",
            "How they heard about us": "={{ $json['How they heard about us'] }}",
            "Lead Qualifier": "={{ $json['Lead Qualifier'] }}",
            "Referred By": "={{ $json.referredBy }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "Timestamp",
              "displayName": "Timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Id",
              "displayName": "Id",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Lead Type",
              "displayName": "Lead Type",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "First Name",
              "displayName": "First Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Last Name",
              "displayName": "Last Name",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Mobile Number",
              "displayName": "Mobile Number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Phone Number",
              "displayName": "Phone Number",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Email Address",
              "displayName": "Email Address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Address",
              "displayName": "Address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "State",
              "displayName": "State",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Suburb",
              "displayName": "Suburb",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Postal Code",
              "displayName": "Postal Code",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Enquiry",
              "displayName": "Enquiry",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Quantity",
              "displayName": "Quantity",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "I’d Like To Get My Project Underway",
              "displayName": "I’d Like To Get My Project Underway",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "How they heard about us",
              "displayName": "How they heard about us",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Lead Qualifier",
              "displayName": "Lead Qualifier",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true
            },
            {
              "id": "Referred By",
              "displayName": "Referred By",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {
          "useAppend": true
        }
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.7,
      "position": [
        2272,
        -208
      ],
      "id": "af174a0a-ee39-44ce-bf18-e7b2266c7b5f",
      "name": "Append row in sheet",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "S4FmXrss6MgN5rzt",
          "name": "WR: Google Sheets Account"
        }
      }
    },
    {
      "parameters": {
        "operation": "addLabels",
        "messageId": "={{ $json.Id }}",
        "labelIds": [
          "Label_169"
        ]
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        2720,
        -184
      ],
      "id": "b3e872fb-fc5e-437e-aa95-341c711446ce",
      "name": "Add label to message",
      "webhookId": "eaa86f78-77f7-4ad4-9bd6-4a166aee264b",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "61b9b0d9-8451-470a-a782-ccf3201f846d",
              "leftValue": "={{ $json['Lead Qualifier'] }}",
              "rightValue": "Good",
              "operator": {
                "type": "string",
                "operation": "equals",
                "name": "filter.operator.equals"
              }
            }
          ],
          "combinator": "or"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        2496,
        -208
      ],
      "id": "218e3f2e-432a-4f1d-82d8-0c83f040ea41",
      "name": "If"
    },
    {
      "parameters": {
        "jsCode": "// =============== Helpers ===============\n\nfunction normalizeDigits(str) {\n  if (!str) return '';\n  return String(str).replace(/\\D+/g, '');\n}\n\n// Normalise any AU-looking phone number to digits starting with 0 and 10 digits if possible\nfunction normalizeAuPhone(raw) {\n  let digits = normalizeDigits(raw);\n  if (!digits) return '';\n\n  // Handle +61 / 61 prefix\n  if (digits.startsWith('61')) {\n    digits = '0' + digits.slice(2); // 61 4xx... -> 04xx...\n  }\n\n  // If it starts with 4 and is 9 digits, assume missing leading 0\n  if (!digits.startsWith('0') && digits.length === 9 && digits.startsWith('4')) {\n    digits = '0' + digits;\n  }\n\n  // At this point, typical AU number is \"0xxxxxxxxx\" (10 digits)\n  return digits;\n}\n\nfunction formatAuPhoneFromDigits(digits) {\n  if (!digits) return '';\n\n  if (digits.length === 10 && digits.startsWith('04')) {\n    // mobile 04xx xxx xxx\n    return digits.replace(/(\\d{4})(\\d{3})(\\d{3})/, '$1 $2 $3');\n  }\n\n  if (digits.length === 10 && digits.startsWith('0')) {\n    // landline 0x xxxx xxxx\n    return digits.replace(/(\\d{2})(\\d{4})(\\d{4})/, '$1 $2 $3');\n  }\n\n  // fall back to raw digits if something odd\n  return digits;\n}\n\n// Execution-time helper used ONLY to generate Timestamp now\nfunction getExecutionTimes() {\n  const now = new Date();\n  return {\n    executionBrisbane: now.toLocaleString('en-AU', {\n      timeZone: 'Australia/Brisbane',\n      hour12: false, // 24h format\n    }),\n    executionUtcIso: now.toISOString(),\n    executionEpochMs: now.getTime(),\n  };\n}\n\n// Simple AU-phone based spam logic\nfunction isSpamLead(parsed) {\n  const first = (parsed.firstName || '').trim();\n  const last  = (parsed.lastName  || '').trim();\n\n  const normPhone = normalizeAuPhone(parsed.phoneNumberRaw || '');\n\n  const hasName  = first.length >= 2 && last.length >= 2;\n  const hasPhone = normPhone.length >= 9; // allow 9–10 digits after normalisation\n\n  const nameCombo = (first + ' ' + last).toLowerCase();\n\n  if (!hasName || !hasPhone) return true;\n  if (nameCombo.includes('test') || nameCombo.includes('asdf')) return true;\n  if (nameCombo.includes('sdr')) return true;\n\n  return false;\n}\n\n// =============== Facebook-specific parser ===============\n\n// Handles strings like:\n// \"... Comments/Questions: ... Email: ... First Name: X Last Name: Y Phone Number: +61... Please Select What You Want Fixing:: ... Quantity: 1 Time Frame For Repairs?: now Which Suburb?: Kurwongbah View this lead in Privyr ...\"\nfunction parseFacebookText(rawText) {\n  if (!rawText) return {};\n\n  // Collapse whitespace so everything is on one line\n  const text = rawText.replace(/\\s+/g, ' ');\n\n  const markerDefs = [\n    { key: 'comments',       marker: 'Comments/Questions:' },\n    { key: 'email',          marker: 'Email:' },\n    { key: 'firstName',      marker: 'First Name:' },\n    { key: 'lastName',       marker: 'Last Name:' },\n    { key: 'phoneNumberRaw', marker: 'Phone Number:' },\n    { key: 'service',        marker: 'Please Select What You Want Fixing::' },\n    { key: 'quantity',       marker: 'Quantity:' },\n    { key: 'timeFrame',      marker: 'Time Frame For Repairs?:' },\n    { key: 'suburb',         marker: 'Which Suburb?:' },\n\n    // Boundary AFTER suburb, so suburb doesn't eat the rest of the email\n    { key: null,             marker: 'View this lead in Privyr' },\n  ];\n\n  const positions = [];\n\n  for (const m of markerDefs) {\n    const idx = text.indexOf(m.marker);\n    if (idx === -1) continue;\n    positions.push({\n      key: m.key,\n      markerIndex: idx,\n      valueStart: idx + m.marker.length,\n    });\n  }\n\n  if (!positions.length) return {};\n\n  positions.sort((a, b) => a.markerIndex - b.markerIndex);\n\n  const result = {};\n\n  for (let i = 0; i < positions.length; i++) {\n    const curr = positions[i];\n    const next = positions[i + 1];\n    const end  = next ? next.markerIndex : text.length;\n    const value = text.slice(curr.valueStart, end).trim();\n    if (curr.key && value) {\n      result[curr.key] = value;\n    }\n  }\n\n  // Fallback in case email marker fails\n  if (!result.email) {\n    const emailMatch = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n    if (emailMatch) result.email = emailMatch[0];\n  }\n\n  return result;\n}\n\n// =============== Main mapping ===============\n\n// Snapshot execution time ONCE per Function node run\nconst execTime = getExecutionTimes();\n\nreturn items.map(item => {\n  const json    = item.json || {};\n  const id      = json.id || '';\n  const rawText = json.text || json.textHtml || json.snippet || '';\n\n  const parsed = parseFacebookText(rawText);\n\n  // Normalise & format phone\n  const rawPhone   = parsed.phoneNumberRaw || '';\n  const normDigits = normalizeAuPhone(rawPhone);\n\n  let mobileFormatted = '';\n  let phoneFormatted  = '';\n\n  if (normDigits.startsWith('04') && normDigits.length === 10) {\n    // treat as mobile\n    mobileFormatted = formatAuPhoneFromDigits(normDigits);\n  } else if (normDigits.startsWith('0') && normDigits.length === 10) {\n    // treat as landline\n    phoneFormatted = formatAuPhoneFromDigits(normDigits);\n  } else if (normDigits) {\n    // unknown style but keep it in Phone Number\n    phoneFormatted = normDigits;\n  }\n\n  // Timestamp must match \"Execution Time (Brisbane)\" format\n  const timestamp = execTime.executionBrisbane;\n\n  const leadQualifier = isSpamLead(parsed) ? 'Spam' : 'Good';\n\n  return {\n    json: {\n      // ===== Single timestamp field only =====\n      Timestamp: timestamp,\n\n      // ===== Original fields =====\n      Id: id,\n\n      // Hard-coded for this source\n      'Lead Type': 'Facebook Lead',\n\n      'First Name': parsed.firstName || '',\n      'Last Name':  parsed.lastName  || '',\n      'Mobile Number': mobileFormatted,\n      'Phone Number':  phoneFormatted,\n      'Email Address': parsed.email || '',\n      'Address': '',\n      State: '',\n      Suburb: parsed.suburb || '',\n      'Postal Code': '',\n      Enquiry: parsed.comments || parsed.service || '',\n      Quantity: parsed.quantity || '',\n      \"I'd Like To Get My Project Underway\": parsed.timeFrame || '',\n      'How they heard about us': 'Facebook',\n      'Lead Qualifier': leadQualifier,\n    },\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2048,
        -112
      ],
      "id": "d89fe4b9-2a8b-4556-b828-8be983375004",
      "name": "FB Parsing"
    },
    {
      "parameters": {
        "jsCode": "// items: array of input items from Gmail Get Many\n// each item.json has at least: { id, text }\n\nfunction normalizeDigits(str) {\n  if (!str) return '';\n  return String(str).replace(/\\D+/g, '');\n}\n\nfunction formatAuPhone(raw, type) {\n  if (!raw) return '';\n  let digits = normalizeDigits(raw);\n  if (!digits) return '';\n\n  // Handle +61 or 61 prefix\n  if (digits.startsWith('61')) {\n    digits = '0' + digits.slice(2);\n  } else if (!digits.startsWith('0') && digits.length >= 9) {\n    // Assume missing leading 0\n    digits = '0' + digits;\n  }\n\n  // Mobile\n  if (type === 'mobile') {\n    if (digits.length === 10) {\n      // 04xx xxx xxx\n      return digits.replace(/(\\d{4})(\\d{3})(\\d{3})/, '$1 $2 $3');\n    }\n  }\n\n  // Landline\n  if (type === 'landline') {\n    if (digits.length === 10) {\n      // 0x xxxx xxxx\n      return digits.replace(/(\\d{2})(\\d{4})(\\d{4})/, '$1 $2 $3');\n    }\n  }\n\n  // Fallback\n  return digits;\n}\n\nfunction getBrisbaneDate(json) {\n  let date;\n\n  if (json.internalDate) {\n    // Gmail internalDate is ms since epoch as string\n    date = new Date(Number(json.internalDate));\n  } else {\n    // For test payloads (id + text only), just use \"now\"\n    date = new Date();\n  }\n\n  // dd/mm/yyyy, HH:MM:SS in Australia/Brisbane\n  return date.toLocaleString('en-AU', {\n    timeZone: 'Australia/Brisbane',\n    hour12: false,          // 24-hour time\n  });\n}\n\n// Parse both styles:\n// - \"First NameDonLast NamePuertoEmail...\"\n// - \"First Name NENdpIiv... \\nLast Name Dbbd...\"\nfunction parseFormText(rawText) {\n  if (!rawText) return {};\n\n  // Remove newlines so markers are continuous\n  const text = rawText.replace(/\\r?\\n/g, ' ');\n\n  const markerDefs = [\n    { key: 'firstName',      marker: 'First Name' },\n    { key: 'lastName',       marker: 'Last Name' },\n    { key: 'email',          marker: 'Email' },\n    { key: 'phoneNumberRaw', marker: 'Phone Number' },\n    { key: 'suburb',         marker: 'Suburb' },\n    { key: 'state',          marker: 'State' },\n    { key: 'enquiry',        marker: 'Enquiry' },\n    { key: 'projectTiming',  marker: \"I'd Like To Get My Project Underway...\" },\n    { key: 'howHeard',       marker: 'How did yopu here about us' }, // older form\n    // boundaries\n    { key: null,             marker: 'Brands' },\n    { key: null,             marker: 'Services' },\n    { key: 'quantity',       marker: 'Quantity' }\n  ];\n\n  const positions = [];\n\n  for (const m of markerDefs) {\n    const idx = text.indexOf(m.marker);\n    if (idx === -1) continue;\n    positions.push({\n      key: m.key,\n      markerIndex: idx,\n      valueStart: idx + m.marker.length,\n    });\n  }\n\n  if (!positions.length) return {};\n\n  positions.sort((a, b) => a.markerIndex - b.markerIndex);\n\n  const result = {};\n\n  for (let i = 0; i < positions.length; i++) {\n    const curr = positions[i];\n    const next = positions[i + 1];\n    const end = next ? next.markerIndex : text.length;\n    const value = text.slice(curr.valueStart, end).trim();\n\n    if (curr.key && value) {\n      result[curr.key] = value;\n    }\n  }\n\n  // Fallback: email regex if not caught by marker\n  if (!result.email) {\n    const emailMatch = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n    if (emailMatch) result.email = emailMatch[0];\n  }\n\n  return result;\n}\n\n// Helper: is this an Australian-style phone number?\nfunction isValidAuPhone(phoneDigits) {\n  if (!phoneDigits) return false;\n\n  // +61 already normalised before this, so we expect 0xxxxxxxxx\n  if (phoneDigits.startsWith('04') && phoneDigits.length === 10) return true; // mobile\n  if (phoneDigits.startsWith('0') && phoneDigits.length === 10) return true;  // landline\n\n  return false;\n}\n\nfunction isSpamLead(parsed) {\n  const first = (parsed.firstName || '').trim();\n  const last  = (parsed.lastName  || '').trim();\n  const phoneRaw    = parsed.phoneNumberRaw || '';\n  const phoneDigits = normalizeDigits(phoneRaw);\n\n  const hasName  = first.length >= 2 && last.length >= 2;\n  const hasPhone = isValidAuPhone(phoneDigits);   // *** AU-only now ***\n\n  const nameCombo = (first + ' ' + last).toLowerCase();\n\n  // Basic spam rules\n  if (!hasName || !hasPhone) return true;           // missing AU phone → spam\n  if (nameCombo.includes('test') || nameCombo.includes('asdf')) return true;\n  if (nameCombo.includes('sdr')) return true;       // your SDR test names\n\n  return false;\n}\n\n// Main mapping over items\nreturn items.map(item => {\n  const json = item.json || {};\n  const id = json.id || '';\n  const rawText = json.text || json.textPlain || json.snippet || '';\n\n  const parsed = parseFormText(rawText);\n\n  // Single \"Phone Number\" field → decide mobile vs landline\n  const phoneRaw    = parsed.phoneNumberRaw || '';\n  const phoneDigits = normalizeDigits(phoneRaw);\n  let mobileFormatted = '';\n  let phoneFormatted  = '';\n\n  if (phoneDigits.startsWith('04') && phoneDigits.length === 10) {\n    // AU mobile\n    mobileFormatted = formatAuPhone(phoneRaw, 'mobile');\n  } else if (phoneDigits.length === 10 && phoneDigits.startsWith('0')) {\n    // AU landline\n    phoneFormatted = formatAuPhone(phoneRaw, 'landline');\n  } else if (phoneDigits) {\n    // Non-AU or weird → keep raw digits in Phone Number (still marked as spam)\n    phoneFormatted = phoneDigits;\n  }\n\n  const timestamp     = getBrisbaneDate(json);\n  const leadQualifier = isSpamLead(parsed) ? 'Spam' : 'Good';\n\n  return {\n    json: {\n      Timestamp: timestamp,\n      Id: id,\n      // *** Hard-coded for this flow ***\n      'Lead Type': 'Windowrevival.NET Lead',\n\n      'First Name': parsed.firstName || '',\n      'Last Name':  parsed.lastName  || '',\n      'Mobile Number': mobileFormatted,\n      'Phone Number':  phoneFormatted,\n      'Email Address': parsed.email || '',\n      'Address': parsed.address || '',\n      State:  parsed.state  || '',\n      Suburb: parsed.suburb || '',\n      'Postal Code': parsed.postalCode || '',\n      Enquiry: parsed.enquiry || '',\n      Quantity: parsed.quantity || '',\n      \"I'd Like To Get My Project Underway\": parsed.projectTiming || '',\n      'How they heard about us': parsed.howHeard || '',\n      'Lead Qualifier': leadQualifier, // \"Good\" or \"Spam\"\n      'referredBy': '',  \n      //_rawText: rawText,\n    },\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2048,
        -304
      ],
      "id": "b1f79931-60ad-41e8-8c3b-4c815c7d52c1",
      "name": "Windowrevival.NET Parsing"
    },
    {
      "parameters": {
        "jsCode": "// items: array of input items from Gmail Get Many\n// each item.json has at least: { id, text }\n\nfunction normalizeDigits(str) {\n  if (!str) return '';\n  return String(str).replace(/\\D+/g, '');\n}\n\nfunction formatAuPhone(raw, type) {\n  if (!raw) return '';\n  let digits = normalizeDigits(raw);\n  if (!digits) return '';\n\n  // Handle +61 or 61 prefix\n  if (digits.startsWith('61')) {\n    digits = '0' + digits.slice(2);\n  } else if (!digits.startsWith('0') && digits.length >= 9) {\n    // Assume missing leading 0\n    digits = '0' + digits;\n  }\n\n  // Mobile\n  if (type === 'mobile') {\n    if (digits.length === 10) {\n      // 04xx xxx xxx\n      return digits.replace(/(\\d{4})(\\d{3})(\\d{3})/, '$1 $2 $3');\n    }\n  }\n\n  // Landline\n  if (type === 'landline') {\n    if (digits.length === 10) {\n      // 0x xxxx xxxx\n      return digits.replace(/(\\d{2})(\\d{4})(\\d{4})/, '$1 $2 $3');\n    }\n  }\n\n  // Fallback\n  return digits;\n}\n\nfunction getBrisbaneDate(json) {\n  let date;\n\n  if (json.internalDate) {\n    // Gmail internalDate is ms since epoch as string\n    date = new Date(Number(json.internalDate));\n  } else {\n    // For your test payload (id + text only), just use \"now\"\n    date = new Date();\n  }\n\n  // \"dd/mm/yyyy, HH:MM:SS\" in Australia/Brisbane\n  return date.toLocaleString('en-AU', {\n    timeZone: 'Australia/Brisbane',\n    hour12: false, // 24-hour time\n  });\n}\n\n// Parse \"First NameDonLast NamePuertoEmail...\" style text\nfunction parseFormText(rawText) {\n  if (!rawText) return {};\n\n  // Remove newlines so markers are continuous\n  const text = rawText.replace(/\\r?\\n/g, ' ');\n\n  // Markers in the order they appear in the form\n  const markerDefs = [\n    { key: 'firstName',      marker: 'First Name' },\n    { key: 'lastName',       marker: 'Last Name' },\n    { key: 'email',          marker: 'Email' },\n    { key: 'phoneNumberRaw', marker: 'Phone Number' },\n    { key: 'suburb',         marker: 'Suburb' },\n    { key: 'state',          marker: 'State' },\n    { key: 'enquiry',        marker: 'Enquiry' },\n    { key: 'projectTiming',  marker: \"I'd Like To Get My Project Underway...\" },\n    { key: 'howHeard',       marker: 'How did yopu here about us' },\n    // boundaries\n    { key: null,             marker: 'Brands' },\n    { key: null,             marker: 'Services' },\n    { key: 'quantity',       marker: 'Quantity' }\n  ];\n\n  const positions = [];\n\n  for (const m of markerDefs) {\n    const idx = text.indexOf(m.marker);\n    if (idx === -1) continue;\n    positions.push({\n      key: m.key,\n      markerIndex: idx,\n      valueStart: idx + m.marker.length,\n    });\n  }\n\n  if (!positions.length) return {};\n\n  // Sort by position\n  positions.sort((a, b) => a.markerIndex - b.markerIndex);\n\n  const result = {};\n\n  for (let i = 0; i < positions.length; i++) {\n    const curr = positions[i];\n    const next = positions[i + 1];\n    const end = next ? next.markerIndex : text.length;\n    const value = text.slice(curr.valueStart, end).trim();\n\n    if (curr.key && value) {\n      result[curr.key] = value;\n    }\n  }\n\n  // Fallback: email regex if not caught by marker\n  if (!result.email) {\n    const emailMatch = text.match(/[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/i);\n    if (emailMatch) result.email = emailMatch[0];\n  }\n\n  return result;\n}\n\nfunction isSpamLead(parsed) {\n  const first = (parsed.firstName || '').trim();\n  const last = (parsed.lastName || '').trim();\n  const phoneRaw = parsed.phoneNumberRaw || '';\n  const phoneDigits = normalizeDigits(phoneRaw);\n\n  const hasName = first.length >= 2 && last.length >= 2;\n  const hasPhone = phoneDigits.length >= 9;\n\n  const nameCombo = (first + ' ' + last).toLowerCase();\n\n  // Basic spam rules\n  if (!hasName || !hasPhone) return true;\n  if (nameCombo.includes('test') || nameCombo.includes('asdf')) return true;\n  if (nameCombo.includes('sdr')) return true; // your SDR test names\n\n  return false;\n}\n\n// Main mapping over items\nreturn items.map(item => {\n  const json = item.json || {};\n  const id = json.id || '';\n  const rawText = json.text || json.textPlain || json.snippet || '';\n\n  const parsed = parseFormText(rawText);\n\n  // Single \"Phone Number\" field → decide mobile vs landline\n  const phoneRaw = parsed.phoneNumberRaw || '';\n  const phoneDigits = normalizeDigits(phoneRaw);\n  let mobileFormatted = '';\n  let phoneFormatted = '';\n\n  if (phoneDigits.startsWith('04') && phoneDigits.length === 10) {\n    // AU mobile\n    mobileFormatted = formatAuPhone(phoneRaw, 'mobile');\n  } else if (phoneDigits.length === 10 && phoneDigits.startsWith('0')) {\n    // AU landline\n    phoneFormatted = formatAuPhone(phoneRaw, 'landline');\n  } else if (phoneDigits) {\n    phoneFormatted = phoneDigits;\n  }\n\n  const timestamp = getBrisbaneDate(json);\n  const leadQualifier = isSpamLead(parsed) ? 'Spam' : 'Good';\n\n  return {\n    json: {\n      Timestamp: timestamp,                     // e.g. \"21/11/2025, 08:25:40\"\n      Id: id,\n      'Lead Type': 'Sliding Door Lead',\n\n      'First Name': parsed.firstName || '',\n      'Last Name': parsed.lastName || '',\n      'Mobile Number': mobileFormatted,\n      'Phone Number': phoneFormatted,\n      'Email Address': parsed.email || '',\n      'Address': parsed.address || '',\n      State: parsed.state || '',\n      Suburb: parsed.suburb || '',\n      'Postal Code': parsed.postalCode || '',\n      Enquiry: parsed.enquiry || '',\n      Quantity: parsed.quantity || '',\n      \"I'd Like To Get My Project Underway\": parsed.projectTiming || '',\n      'How they heard about us': parsed.howHeard || '',\n      'Lead Qualifier': leadQualifier,\n\n      referredBy: '',          // always empty string for Google Sheets\n\n      //_rawText: rawText\n    }\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2048,
        -496
      ],
      "id": "e3556fae-4397-4cb7-9257-36cb4b756160",
      "name": "SDR Parsing"
    },
    {
      "parameters": {
        "resource": "message",
        "guildId": {
          "__rl": true,
          "value": "753455160209965106",
          "mode": "list",
          "cachedResultName": "Window Revival",
          "cachedResultUrl": "https://discord.com/channels/753455160209965106"
        },
        "channelId": {
          "__rl": true,
          "value": "912496260823519232",
          "mode": "list",
          "cachedResultName": "leads・new",
          "cachedResultUrl": "https://discord.com/channels/753455160209965106/912496260823519232"
        },
        "content": "===========\nLead Type: {{ $json['Lead Type'] }}\nTimestamp: {{ $json.Timestamp }}\nId: {{ $json.Id }}\nFirst Name: {{ $json['First Name'] }}\nLast Name: {{ $json['Last Name'] }}\nMobile Number: {{ $json['Mobile Number'] }}\nPhone Number: {{ $json['Phone Number'] }}\nEmail Address: {{ $json['Email Address'] }}\nAddress: {{ $json.Address }}\nState: {{ $json.State }}\nSuburb: {{ $json.Suburb }}\nPostal Code: {{ $json['Postal Code'] }}\nEnquiry: {{ $json.Enquiry }}\nQuantity: {{ $json.Quantity }}\nI'd Like To Get my Project Underway: {{ $json['I’d Like To Get My Project Underway'] }}\nHow they heard about us?: {{ $json['How they heard about us'] }}",
        "options": {}
      },
      "type": "n8n-nodes-base.discord",
      "typeVersion": 2,
      "position": [
        2944,
        8
      ],
      "id": "159dd08f-7ff7-41c1-831d-4cb8e92a1924",
      "name": "Send a message",
      "webhookId": "6ee999bf-5345-4131-841d-ceb3f3c6bf08",
      "credentials": {
        "discordBotApi": {
          "id": "a0FDlWFh8PBA5Add",
          "name": "WR: Discord Bot Account"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "messageId": "={{ $json.id }}"
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        3168,
        200
      ],
      "id": "798038b9-9a90-4767-9015-d8d0d761f112",
      "name": "Delete spam email",
      "webhookId": "a8db06db-cdc7-49e6-b2df-3deaef7d9918",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      }
    },
    {
      "parameters": {
        "operation": "get",
        "messageId": "={{ $json.Id }}"
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        2720,
        200
      ],
      "id": "dc82edbd-673d-400f-81cd-5eed3b3c178c",
      "name": "Check id if exist before deleting",
      "webhookId": "4281927b-5f56-4ccd-b4c5-6e189977c0e4",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2720,
        -376
      ],
      "id": "59fc5d19-f5e9-4da7-8093-c51190ccf840",
      "name": "Send to Wrapp",
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  item.json.myNewField = 1;\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2944,
        200
      ],
      "id": "3a7e7647-a8f8-43de-9270-0cf2e00951fa",
      "name": "Get Ids"
    },
    {
      "parameters": {
        "amount": 10
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2720,
        8
      ],
      "id": "77bbde47-ee7a-4c21-a6fb-48208aaf6cab",
      "name": "Wait",
      "webhookId": "993642a3-c234-434d-9030-600168b568a9"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -1664,
        -16
      ],
      "id": "0116741e-b199-4e12-9dea-7a393a4fd78c",
      "name": "Trigger every 5 minute"
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -1440,
        -112
      ],
      "id": "ae545fef-6c7b-4e2d-9feb-cd18c8f854df",
      "name": "Wait1",
      "webhookId": "b0e66fee-c034-49fd-bc17-00b7ecdc62f0"
    },
    {
      "parameters": {
        "operation": "getAll",
        "limit": 20,
        "filters": {
          "labelIds": [
            "Label_8054278402706687750"
          ],
          "readStatus": "both"
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        -1216,
        -112
      ],
      "id": "574c302e-da14-4d4f-828d-b58a921c6dc9",
      "name": "Get Many Emails",
      "webhookId": "9263e7dd-7a75-4aa9-9772-f263d19d6415",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      }
    },
    {
      "parameters": {
        "amount": 1
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        -768,
        -112
      ],
      "id": "6d2c7ec4-7008-4311-919c-f65a6c4edefb",
      "name": "Wait2",
      "webhookId": "3c14dce5-42bc-44eb-8d63-f64b038e01a2"
    },
    {
      "parameters": {
        "fieldToSplitOut": "id",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -992,
        -112
      ],
      "id": "545cbb11-0d0d-4979-b62c-f5f69e88bb61",
      "name": "Split Emails"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.labelIds || [] }}\n",
                    "rightValue": "Label_236316694232257385",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    },
                    "id": "853ec203-7401-4dd6-a636-9c3e2f143ce3"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "SDR"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "73d43b3e-4e0a-42e5-a797-65e5a4ca424f",
                    "leftValue": "={{ $json.labelIds || [] }}",
                    "rightValue": "Label_5972230113927178957",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "WR.net"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "dfdfd523-8675-4581-96b9-a2da47598c30",
                    "leftValue": "={{ $json.labelIds || [] }}",
                    "rightValue": "Label_4464659176251527724",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Facebook"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "b2a6c721-b36e-4492-ab27-200dd405c2da",
                    "leftValue": "={{ $json.labelIds || [] }}",
                    "rightValue": "3. Leads/3.8 Email Enquiry Gen",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Email Enquiry"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "loose",
                  "version": 3
                },
                "conditions": [
                  {
                    "id": "38cee0bf-368d-41db-a96e-e03566c8ef72",
                    "leftValue": "={{ $json.labelIds || [] }}",
                    "rightValue": "Label_8054278402706687750",
                    "operator": {
                      "type": "string",
                      "operation": "contains"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Work Order/Quote Order"
            }
          ]
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        128,
        -160
      ],
      "id": "9ba8954f-50a1-402e-ad33-65816096b0bc",
      "name": "Router"
    },
    {
      "parameters": {
        "operation": "get",
        "messageId": "={{ $json.id }}",
        "simple": false,
        "options": {
          "downloadAttachments": true
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [
        -544,
        -112
      ],
      "id": "8955af0c-593f-40b0-b016-7fe317128f44",
      "name": "Get a message",
      "webhookId": "275e7ad1-840b-42e1-a85e-12300622ea25",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "e570add7-64c9-4339-b667-670a56ad8fa0",
              "leftValue": "={{ $json[\"labelIds\"].join(\",\") }}\n\n",
              "rightValue": "=Label_169",
              "operator": {
                "type": "string",
                "operation": "notContains"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -320,
        -112
      ],
      "id": "b782e080-984d-48d5-83ec-b249a8a12ac6",
      "name": "Ensure no label \"Label_169\" or Processed by n8n pass"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
              "name": "id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
              "name": "text",
              "value": "={{ $json.text }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1760,
        -496
      ],
      "id": "2fb548b8-58e3-47d0-be22-bf932c823c1a",
      "name": "Get Id and Text for SDR"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
              "name": "id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
              "name": "text",
              "value": "={{ $json.text }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1760,
        -304
      ],
      "id": "733579d9-e757-406b-bbe9-df04afb559d6",
      "name": "Get Id and Text for Windowrevival.NET"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
              "name": "id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
              "name": "text",
              "value": "={{ $json.text }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1760,
        -112
      ],
      "id": "4ac5f6c1-8438-42da-9ef2-02425661c7c5",
      "name": "Get Id and Text for Facebook"
    },
    {
      "parameters": {
        "resource": "label",
        "limit": 200
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.2,
      "position": [
        -1440,
        80
      ],
      "id": "c6d9901b-0c0e-4010-946c-0e768eeb5edc",
      "name": "Get many labels",
      "webhookId": "d169cf30-b956-4787-8721-cc8c5bb4cc24",
      "credentials": {
        "gmailOAuth2": {
          "id": "Iacb6DlpUsfDqQMK",
          "name": "WR: Gmail Account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "// This node \"freezes\" attachment metadata into JSON while keeping binary intact.\n// Router/other nodes sometimes drop binary; this reduces surprises and makes\n// downstream PDF filtering easier.\n\nreturn items.map(item => {\n  const bin = item.binary || {};\n  const attachments = Object.keys(bin).map(key => {\n    const b = bin[key] || {};\n    return {\n      key,                               // binary key like attachment_0\n      fileName: b.fileName || '',\n      mimeType: b.mimeType || '',\n      fileExtension: b.fileExtension || '',\n      fileSize: b.fileSize || 0,\n    };\n  });\n\n  item.json.attachments = attachments;\n  item.json.pdfAttachments = attachments.filter(a =>\n    (a.mimeType || '').toLowerCase() === 'application/pdf' ||\n    (a.fileExtension || '').toLowerCase() === 'pdf' ||\n    (a.fileName || '').toLowerCase().endsWith('.pdf')\n  );\n\n  item.json.pdfCount = item.json.pdfAttachments.length;\n\n  return item;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -96,
        -112
      ],
      "id": "5ae8c712-90ee-47a7-b30c-92d371c5855c",
      "name": "Preserve attachments"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 3
          },
          "conditions": [
            {
              "id": "db6a1784-302c-49c1-a31d-cbec0d44128a",
              "leftValue": "={{ \n  Object.values($binary || {}).some(b => {\n    const mime = (b.mimeType || '').toLowerCase();\n    const name = (b.fileName || '').toLowerCase();\n    return mime === 'application/pdf' || mime.includes('pdf') || name.endsWith('.pdf');\n  })\n}}\n",
              "rightValue": "",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -1664,
        736
      ],
      "id": "7134709c-6531-4c43-b02c-1917ab6da570",
      "name": "Has PDF?",
      "disabled": true
    },
    {
      "parameters": {
        "fieldToSplitOut": "attachment",
        "include": "allOtherFields",
        "options": {}
      },
      "type": "n8n-nodes-base.splitOut",
      "typeVersion": 1,
      "position": [
        -1664,
        1408
      ],
      "id": "6e777304-03db-41a3-8dd2-4cbc1ea8d76a",
      "name": "Extract PDF text"
    },
    {
      "parameters": {
        "operation": "pdf",
        "options": {}
      },
      "type": "n8n-nodes-base.extractFromFile",
      "typeVersion": 1.1,
      "position": [
        800,
        108
      ],
      "id": "e72170d4-3d42-43ad-91d9-a7effcaa6468",
      "name": "Extract from File"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "85afdd48-f009-4291-8774-a261bf4a4c79",
              "name": "id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "dc93f011-914a-435f-a2b9-89a3781ad46f",
              "name": "threadId",
              "value": "={{ $json.threadId }}",
              "type": "string"
            },
            {
              "id": "6b5505e7-19ca-4065-b162-c9ce00799f7f",
              "name": "from",
              "value": "={{ $json.from?.value?.[0]?.address || $json.headers?.from || '' }}\n\n",
              "type": "string"
            },
            {
              "id": "738733ee-2ed9-4a25-997d-7d69288cae20",
              "name": "subject",
              "value": "={{ $json.subject || ($json.headers?.subject ?? '') }}\n",
              "type": "string"
            },
            {
              "id": "926d5470-19d4-42b4-a438-bd8f828a3346",
              "name": "emailText",
              "value": "={{ $json.text || '' }}\n",
              "type": "string"
            },
            {
              "id": "35fd5361-ac87-471c-b521-02be618e69d5",
              "name": "emailHtml",
              "value": "={{ $json.textAsHtml || '' }}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1664,
        960
      ],
      "id": "2fa2a855-5783-4456-a39a-33edc62878f6",
      "name": "Get email meta for WorkOrder/QuoteOrder",
      "disabled": true
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "015be041-8c3c-4249-885b-d693bc855db6",
              "name": "id",
              "value": "={{ $json.id }}\n",
              "type": "string"
            },
            {
              "id": "e055ef97-d725-4e83-9e92-a3dcc6b1f999",
              "name": "threadId",
              "value": "={{ $json.threadId }}\n",
              "type": "string"
            },
            {
              "id": "9f559eb6-2656-4aae-9367-4302b6530cb7",
              "name": "from",
              "value": "={{ $json.from?.value?.[0]?.address ?? $json.from ?? \"\" }}\n",
              "type": "string"
            },
            {
              "id": "8d11132e-6892-45ad-bf4c-2c5453e0b463",
              "name": "emailText",
              "value": "={{ $json.text ?? $json.snippet ?? \"\" }}\n",
              "type": "string"
            },
            {
              "id": "52bcb2fe-303f-4287-9d2c-bac0825e4488",
              "name": "emailHtml",
              "value": "={{ $json.html ?? \"\" }}",
              "type": "string"
            },
            {
              "id": "07b2ae01-0f69-43f8-b855-7b408a05d9f2",
              "name": "pdfText",
              "value": "\"\"",
              "type": "string"
            },
            {
              "id": "47557d74-734c-43db-8b2e-984a92676a00",
              "name": "pdfCount",
              "value": 0,
              "type": "number"
            },
            {
              "id": "44c2bdf3-77a6-4a03-bd94-1cb6aed07283",
              "name": "pdfFiles",
              "value": "[]",
              "type": "array"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1664,
        1184
      ],
      "id": "ccf9d04b-db1a-4d43-afd0-83cfa859a63f",
      "name": "No PDF"
    },
    {
      "parameters": {
        "jsCode": "const out = [];\n\nfor (const item of items) {\n  const mergeKey = item.json.mergeKey;\n\n  // ❗ Do NOT generate random merge keys\n  if (!mergeKey) {\n    throw new Error(\n      \"Split PDFs: mergeKey missing. Ensure this node receives output from 'Build Email Meta' and no node in between overwrites json.\"\n    );\n  }\n\n  const bin = item.binary || {};\n  const keys = Object.keys(bin);\n\n  for (const key of keys) {\n    const b = bin[key];\n    if (!b) continue;\n\n    const fileName = (b.fileName || '').toLowerCase();\n    const mime = (b.mimeType || '').toLowerCase();\n    const isPdf = mime === 'application/pdf' || mime.includes('pdf') || fileName.endsWith('.pdf');\n    if (!isPdf) continue;\n\n    out.push({\n      json: {\n        mergeKey,\n        pdfKey: key,\n        pdfFileName: b.fileName || '',\n        pdfMimeType: b.mimeType || '',\n      },\n      binary: {\n        data: b,\n      },\n    });\n  }\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        576,
        108
      ],
      "id": "2c58f02d-aec1-4a99-bba0-0672678897cf",
      "name": "Split PDFs (keep meta)"
    },
    {
      "parameters": {
        "jsCode": "function pickHeader(headers, name) {\n  if (!headers) return '';\n  if (Array.isArray(headers)) {\n    const h = headers.find(x => (x.name || '').toLowerCase() === name.toLowerCase());\n    return h?.value || '';\n  }\n  return headers[name] || headers[name.toLowerCase()] || headers[name.toUpperCase()] || '';\n}\n\nreturn items.map((item, idx) => {\n  const headers = item.json.headers || item.json.payload?.headers || null;\n\n  const subject = item.json.subject || pickHeader(headers, 'Subject');\n  const from = item.json.from || pickHeader(headers, 'From');\n  const to = item.json.to || pickHeader(headers, 'To');\n  const date = item.json.date || pickHeader(headers, 'Date');\n\n  const emailText =\n    item.json.body ||\n    item.json.textPlain ||\n    item.json.text ||\n    item.json.snippet ||\n    '';\n\n  const emailHtml =\n    item.json.html ||\n    item.json.textHtml ||\n    '';\n\n  // ✅ Use Gmail id first. Avoid threadId as mergeKey.\n  const mergeKey =\n    item.json.id ||\n    item.json.messageId ||\n    pickHeader(headers, 'Message-Id') ||\n    `fallback_${idx}`;\n\n  return {\n    json: {\n      mergeKey,\n      emailMeta: {\n        id: item.json.id ?? '',\n        threadId: item.json.threadId ?? '',\n        subject,\n        from,\n        to,\n        date,\n        snippet: item.json.snippet || '',\n        emailText,\n        emailHtml,\n      },\n    },\n    binary: item.binary,\n  };\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        352,
        184
      ],
      "id": "cc46b0f9-21b2-44ba-b344-d4e72747aeaf",
      "name": "Build Email Meta"
    },
    {
      "parameters": {
        "mode": "combine",
        "fieldsToMatchString": "mergeKey",
        "joinMode": "enrichInput1",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1248,
        184
      ],
      "id": "25af6976-c72b-4f5b-85a6-02deaed0819f",
      "name": "Merge TRUE+FALSE"
    },
    {
      "parameters": {
        "jsCode": "const out = [];\n\nfunction hasPdf(bin) {\n  const b = bin || {};\n  return Object.values(b).some(x => {\n    const mime = (x.mimeType || '').toLowerCase();\n    const name = (x.fileName || '').toLowerCase();\n    return mime.includes('pdf') || name.endsWith('.pdf');\n  });\n}\n\nfor (let i = 0; i < items.length; i++) {\n  const item = items[i];\n\n  // If it has a PDF, SKIP\n  if (hasPdf(item.binary)) continue;\n\n  const meta = item.json.emailMeta || {};\n  const mergeKey = item.json.mergeKey || `fallback_${i}`;\n\n  out.push({\n    json: {\n      mergeKey,\n      emailMeta: meta,\n\n      // flat fields (so you SEE data in Table)\n      id: meta.id || '',\n      threadId: meta.threadId || '',\n      subject: meta.subject || '',\n      from: meta.from || '',\n      to: meta.to || '',\n      date: meta.date || '',\n      snippet: meta.snippet || '',\n      emailText: meta.emailText || '',\n      emailHtml: meta.emailHtml || '',\n\n      pdfCount: 0,\n      pdfFiles: [],\n      pdfText: '',\n    },\n  });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1664,
        512
      ],
      "id": "df3ebbd5-06b2-4d68-9123-a9d1d43e9765",
      "name": "Create NO-PDF list from Build Email Meta",
      "disabled": true
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are given an email and optional PDF text.\n\nYour task is to extract lead information and return a JSON object with the EXACT keys listed below.\n\n──────────────── RULES ────────────────\n- Use emailMeta for sender and email details\n- Use pdfText only to enrich information if relevant\n- Do NOT guess or infer values\n- If a field is missing, return an empty string \"\"\n- Timestamp must be ISO 8601 format if present, otherwise \"\"\n- Id MUST use mergeKey\n- Lead Type MUST ALWAYS be \"Work Order Lead\"\n- Lead Qualifier MUST ALWAYS be \"Good\"\n- Address may be found in the PDF, email subject, or email content. Use the most complete Address you can find from these sources without guessing.\n- Postal Code must be extracted ONLY from the Address field (if present)\n- Enquiry MUST include the merged email information AND any relevant PDF contact blocks (if present)\n- Return ONLY valid JSON (no markdown, no explanation)\n\n──────────────── REQUIRED KEYS ────────────────\nTimestamp\nId\nLead Type\nFirst Name\nLast Name\nMobile Number\nPhone Number\nEmail Address\nAddress\nState\nSuburb\nPostal Code\nEnquiry\nQuantity\nI’d Like To Get My Project Underway\nHow they heard about us\nLead Qualifier\nReferred By\n\n──────────────── ENQUIRY FIELD REQUIREMENTS ────────────────\nThe Enquiry field MUST be a readable multi-line text and MUST include:\n\nA) Email details (always include):\nEmail Subject: <subject>\nFrom: <from email>\nTo: <to email if available>\nEmail Content:\n<email body>\n\nB) PDF details (include ONLY if present in PDF text):\n- The full \"For access contact\" block (include name/role/phone/email lines beneath it)\n- The full \"For queries contact\" block (include company/phone/email lines beneath it)\n- The full \"Send invoices to\" block (include names and full postal address beneath it)\n- Any other relevant work order / job description details\n\nIMPORTANT:\n- Preserve line breaks for readability\n- Do not repeat sections (avoid duplicate \"Email Body\" blocks)\n- Do not invent contact details that aren’t explicitly in email/pdf\n\nUse this exact format:\n\nEmail Subject: {{ $json.emailMeta.subject }}\nFrom: {{ $json.emailMeta.from.value[0].address }}\nTo: {{ $json.emailMeta.to?.value?.[0]?.address || '' }}\n\nEmail Content:\n{{ $json.emailMeta.emailText }}\n\nPDF Details:\n{{ $json.pdfText || '' }}\n\n──────────────── INPUT DATA ────────────────\n\nmergeKey:\n{{ $json.mergeKey }}\n\nEmail Subject:\n{{ $json.emailMeta.subject }}\n\nFrom:\n{{ $json.emailMeta.from.value[0].address }}\n\nTo:\n{{ $json.emailMeta.to?.value?.[0]?.address || '' }}\n\nEmail Content:\n{{ $json.emailMeta.emailText }}\n\nPDF Text:\n{{ $json.pdfText || '' }}\n\n──────────────── OUTPUT ────────────────\nReturn ONLY the JSON object.\n",
        "options": {
          "systemMessage": "You are an AI assistant that extracts structured lead data from emails and PDF text.\nYou must return ONLY valid JSON.\nIf a field is missing, return an empty string.\nDo not guess.\nDo not explain.\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        1696,
        184
      ],
      "id": "44c8fdaf-c30b-45e3-981f-b5b6727ff5e1",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4.1-mini"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        1704,
        408
      ],
      "id": "6d0c1990-6901-4d41-a77a-662915823647",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "oQQrCQWqdo1CuRzx",
          "name": "WRai: OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const SPLIT_NODE_NAME = \"Split PDFs (keep meta)\";\n\nconst splitItems = $items(SPLIT_NODE_NAME, 0);\nconst outMap = new Map();\n\nfor (let i = 0; i < items.length; i++) {\n  const extracted = items[i];\n  const meta = splitItems[i]?.json || {};\n\n  const mergeKey = meta.mergeKey;\n  if (!mergeKey) {\n    throw new Error(`Group PDFs: mergeKey missing at index ${i}. Check Split PDFs output.`);\n  }\n\n  if (!outMap.has(mergeKey)) {\n    outMap.set(mergeKey, {\n      json: {\n        mergeKey,\n        pdfCount: 0,\n        pdfFiles: [],\n        pdfText: \"\",\n      },\n    });\n  }\n\n  const agg = outMap.get(mergeKey).json;\n\n  agg.pdfCount += 1;\n  agg.pdfFiles.push({\n    key: meta.pdfKey || \"\",\n    fileName: meta.pdfFileName || \"\",\n    mimeType: meta.pdfMimeType || \"\",\n  });\n\n  const text =\n    extracted.json?.text ??\n    extracted.json?.data ??\n    extracted.json?.content ??\n    extracted.json?.extractedText ??\n    \"\";\n\n  if (String(text).trim()) {\n    agg.pdfText += (agg.pdfText ? \"\\n\\n---\\n\\n\" : \"\");\n    agg.pdfText += `### ${meta.pdfFileName || \"PDF\"}\\n${text}`;\n  }\n}\n\nreturn Array.from(outMap.values());\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1024,
        108
      ],
      "id": "0adad116-0b12-462c-b3f6-8bb810f099de",
      "name": "Group the PDF text"
    },
    {
      "parameters": {
        "jsCode": "return items.map(item => {\n  item.json.pdfText = item.json.pdfText || \"\";\n  item.json.pdfCount = item.json.pdfCount ?? 0;\n  item.json.pdfFiles = item.json.pdfFiles || [];\n  return item;\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1472,
        184
      ],
      "id": "cbbce9df-b163-48d7-a86c-6837c2e8412e",
      "name": "Normalize pdf fields"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Normalize pdf fields').item.json.mergeKey }}",
        "contextWindowLength": "=5"
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        1832,
        408
      ],
      "id": "14e82d74-2c94-4907-8fcb-9bbc4415168e",
      "name": "Simple Memory"
    },
    {
      "parameters": {
        "jsCode": "// ✅ n8n Code node (Run Once for Each Item)\n// Fix: force Id from emailMeta / mergeKey when AI didn't return it\n// Plus: make Enquiry more readable (format + cleanup)\n// Plus: create Timestamp in Brisbane timezone formatted \"DD/MM/YYYY, HH:mm:ss\"\n\nconst input = $input.item.json ?? {};\n\nconst fields = [\n  \"Timestamp\",\"Id\",\"Lead Type\",\"First Name\",\"Last Name\",\"Mobile Number\",\"Phone Number\",\n  \"Email Address\",\"Address\",\"State\",\"Suburb\",\"Postal Code\",\"Enquiry\",\"Quantity\",\n  \"I’d Like To Get My Project Underway\",\"How they heard about us\",\"Lead Qualifier\",\"Referred By\"\n];\n\nfunction deepCollectStrings(x, acc = []) {\n  if (x == null) return acc;\n  if (typeof x === \"string\") { const s = x.trim(); if (s) acc.push(s); return acc; }\n  if (Array.isArray(x)) { for (const v of x) deepCollectStrings(v, acc); return acc; }\n  if (typeof x === \"object\") {\n    const preferredKeys = [\"output_text\",\"text\",\"content\",\"message\",\"value\",\"delta\"];\n    for (const k of preferredKeys) if (k in x) deepCollectStrings(x[k], acc);\n    for (const k of Object.keys(x)) if (!preferredKeys.includes(k)) deepCollectStrings(x[k], acc);\n  }\n  return acc;\n}\n\nfunction stripFences(s){\n  return String(s||\"\")\n    .replace(/^```(?:json)?\\s*/i,\"\")\n    .replace(/```$/i,\"\")\n    .trim();\n}\n\nfunction tryParseJson(s){\n  s = stripFences(s); if (!s) return null;\n  try { return JSON.parse(s); } catch {}\n  const a=s.indexOf(\"{\"), b=s.lastIndexOf(\"}\");\n  if (a!==-1 && b!==-1 && b>a) { try { return JSON.parse(s.slice(a,b+1)); } catch {} }\n  const c=s.indexOf(\"[\"), d=s.lastIndexOf(\"]\");\n  if (c!==-1 && d!==-1 && d>c) { try { return JSON.parse(s.slice(c,d+1)); } catch {} }\n  return null;\n}\n\nfunction parseKeyValueLines(text){\n  const obj = {};\n  const lines = String(text||\"\").split(/\\r?\\n/).map(l=>l.trim()).filter(Boolean);\n  for (const line of lines) {\n    const m =\n      line.match(/^\\-?\\s*([^:]+?)\\s*:\\s*(.*)$/) ||\n      line.match(/^\\-?\\s*([^–-]+?)\\s*[–-]\\s*(.*)$/);\n    if (!m) continue;\n    obj[m[1].trim()] = (m[2]??\"\").trim();\n  }\n  return obj;\n}\n\n// ---------- Timestamp helper (Brisbane) ----------\nfunction brisbaneTimestampNow() {\n  // format: DD/MM/YYYY, HH:mm:ss in Australia/Brisbane\n  const dtf = new Intl.DateTimeFormat(\"en-AU\", {\n    timeZone: \"Australia/Brisbane\",\n    day: \"2-digit\",\n    month: \"2-digit\",\n    year: \"numeric\",\n    hour: \"2-digit\",\n    minute: \"2-digit\",\n    second: \"2-digit\",\n    hour12: false,\n  });\n\n  const parts = Object.fromEntries(dtf.formatToParts(new Date()).map(p => [p.type, p.value]));\n  return `${parts.day}/${parts.month}/${parts.year}, ${parts.hour}:${parts.minute}:${parts.second}`;\n}\n\nfunction looksLikeDesiredTimestampFormat(s) {\n  // DD/MM/YYYY, HH:mm:ss\n  return /^\\d{2}\\/\\d{2}\\/\\d{4}, \\d{2}:\\d{2}:\\d{2}$/.test(String(s || \"\").trim());\n}\n\n// ---------- Enquiry formatting helpers ----------\nfunction normalizeNewlines(s) {\n  return String(s || \"\")\n    .replace(/\\r\\n/g, \"\\n\")\n    .replace(/\\r/g, \"\\n\")\n    .replace(/[ \\t]+\\n/g, \"\\n\")\n    .replace(/\\n{3,}/g, \"\\n\\n\")\n    .trim();\n}\n\nfunction collapseRepeatedAccessContact(s) {\n  const matches = s.match(/for access contact/gi);\n  if (!matches || matches.length <= 1) return s;\n\n  let cleaned = s.replace(/(\\s*for access contact\\s*,?\\s*)+/gi, \"\\nFor access contact\");\n  cleaned = normalizeNewlines(cleaned);\n\n  cleaned = cleaned.replace(/for access contact/gi, (m, offset) => {\n    if (offset === cleaned.toLowerCase().indexOf(\"for access contact\")) {\n      return `For access contact (repeated ${matches.length}x)`;\n    }\n    return \"\";\n  });\n\n  return normalizeNewlines(cleaned);\n}\n\nfunction extractSection(text, label) {\n  const t = normalizeNewlines(text);\n  const re = new RegExp(`(^|\\\\n)${label}\\\\s*:\\\\s*`, \"i\");\n  const m = t.match(re);\n  if (!m) return null;\n\n  const startIdx = m.index + m[0].length;\n  const rest = t.slice(startIdx);\n\n  const stop = rest.search(/\\n(?:Email Subject|From|To|Email Body|PDF Notes|PDF Text)\\s*:/i);\n  const val = (stop === -1 ? rest : rest.slice(0, stop)).trim();\n  return val;\n}\n\nfunction formatEnquiry(enquiryRaw, fallbackEmailMeta, fallbackPdfText) {\n  let s = normalizeNewlines(enquiryRaw);\n\n  if (!s) {\n    const subj = fallbackEmailMeta?.subject || \"\";\n    const from = (fallbackEmailMeta?.from?.text) || fallbackEmailMeta?.from || \"\";\n    const to = (fallbackEmailMeta?.to?.text) || fallbackEmailMeta?.to || \"\";\n    const body = fallbackEmailMeta?.emailText || \"\";\n    const pdf = fallbackPdfText || \"\";\n\n    const parts = [];\n    if (subj) parts.push(`Email Subject: ${subj}`);\n    if (from) parts.push(`From: ${from}`);\n    if (to) parts.push(`To: ${to}`);\n    if (body) parts.push(`Email Body:\\n${body}`);\n    if (pdf) parts.push(`PDF Notes:\\n${pdf}`);\n    s = parts.join(\"\\n\\n\");\n  }\n\n  s = collapseRepeatedAccessContact(s);\n\n  const subject = extractSection(s, \"Email Subject\");\n  const from = extractSection(s, \"From\");\n  const to = extractSection(s, \"To\");\n  const body = extractSection(s, \"Email Body\");\n  const pdfNotes = extractSection(s, \"PDF Notes\") || extractSection(s, \"PDF Text\");\n\n  const hasStructured =\n    subject !== null || from !== null || to !== null || body !== null || pdfNotes !== null;\n\n  if (hasStructured) {\n    const out = [];\n    if (subject) out.push(`Subject: ${subject}`);\n    if (from) out.push(`From: ${from}`);\n    if (to) out.push(`To: ${to}`);\n\n    if (body) {\n      out.push(\"\");\n      out.push(\"Email Body:\");\n      out.push(body);\n    }\n\n    if (pdfNotes) {\n      out.push(\"\");\n      out.push(\"PDF Notes:\");\n      out.push(pdfNotes);\n    }\n\n    let remainder = s;\n    remainder = remainder.replace(/(^|\\n)Email Subject\\s*:[\\s\\S]*?(?=\\n(?:From|To|Email Body|PDF Notes|PDF Text)\\s*:|$)/i, \"\\n\");\n    remainder = remainder.replace(/(^|\\n)From\\s*:[\\s\\S]*?(?=\\n(?:Email Subject|To|Email Body|PDF Notes|PDF Text)\\s*:|$)/i, \"\\n\");\n    remainder = remainder.replace(/(^|\\n)To\\s*:[\\s\\S]*?(?=\\n(?:Email Subject|From|Email Body|PDF Notes|PDF Text)\\s*:|$)/i, \"\\n\");\n    remainder = remainder.replace(/(^|\\n)Email Body\\s*:[\\s\\S]*?(?=\\n(?:Email Subject|From|To|PDF Notes|PDF Text)\\s*:|$)/i, \"\\n\");\n    remainder = remainder.replace(/(^|\\n)PDF (Notes|Text)\\s*:[\\s\\S]*?$/i, \"\\n\");\n    remainder = normalizeNewlines(remainder);\n\n    if (remainder) {\n      out.push(\"\");\n      out.push(\"Other Notes:\");\n      out.push(remainder);\n    }\n\n    s = normalizeNewlines(out.join(\"\\n\"));\n  }\n\n  return s;\n}\n\n// 1) get raw text\nconst raw = deepCollectStrings(input.output ?? input).join(\"\\n\\n\").trim();\n\n// 2) parse\nlet parsed = tryParseJson(raw);\nif (Array.isArray(parsed)) parsed = parsed[0] ?? null;\nif (!parsed || typeof parsed !== \"object\") parsed = parseKeyValueLines(raw);\n\n// 3) build output\nconst out = {};\nfor (const f of fields) out[f] = parsed?.[f] ?? \"\";\n\n// ✅ FORCE Id fallback (most reliable → least)\nconst idFallback =\n  (input?.emailMeta?.id) ||\n  (input?.emailMeta?.threadId) ||\n  (input?.mergeKey) ||\n  (input?.id) ||\n  (input?.threadId) ||\n  \"\";\n\nout[\"Id\"] = out[\"Id\"] || idFallback;\n\n// ✅ Timestamp: always produce Brisbane time in requested format (if missing or wrong format)\nif (!out[\"Timestamp\"] || !looksLikeDesiredTimestampFormat(out[\"Timestamp\"])) {\n  out[\"Timestamp\"] = brisbaneTimestampNow();\n}\n\n// ✅ Make Enquiry more readable\nout[\"Enquiry\"] = formatEnquiry(\n  out[\"Enquiry\"],\n  input?.emailMeta || {},\n  input?.pdfText || \"\"\n);\n\nreturn [{ json: out }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2048,
        184
      ],
      "id": "a7429fc6-3e74-4d9e-8d1a-81f09ae26bf0",
      "name": "Email Work Order Parsing"
    }
  ],
  "connections": {
    "Append row in sheet": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Send to Wrapp",
            "type": "main",
            "index": 0
          },
          {
            "node": "Add label to message",
            "type": "main",
            "index": 0
          },
          {
            "node": "Wait",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Check id if exist before deleting",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "FB Parsing": {
      "main": [
        [
          {
            "node": "Append row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Windowrevival.NET Parsing": {
      "main": [
        [
          {
            "node": "Append row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SDR Parsing": {
      "main": [
        [
          {
            "node": "Append row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete spam email": {
      "main": [
        []
      ]
    },
    "Check id if exist before deleting": {
      "main": [
        [
          {
            "node": "Get Ids",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Ids": {
      "main": [
        [
          {
            "node": "Delete spam email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send a message": {
      "main": [
        []
      ]
    },
    "Wait": {
      "main": [
        [
          {
            "node": "Send a message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger every 5 minute": {
      "main": [
        [
          {
            "node": "Wait1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Get many labels",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait1": {
      "main": [
        [
          {
            "node": "Get Many Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Many Emails": {
      "main": [
        [
          {
            "node": "Split Emails",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait2": {
      "main": [
        [
          {
            "node": "Get a message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Emails": {
      "main": [
        [
          {
            "node": "Wait2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get a message": {
      "main": [
        [
          {
            "node": "Ensure no label \"Label_169\" or Processed by n8n pass",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ensure no label \"Label_169\" or Processed by n8n pass": {
      "main": [
        [
          {
            "node": "Preserve attachments",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Router": {
      "main": [
        [
          {
            "node": "Get Id and Text for SDR",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Id and Text for Windowrevival.NET",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Id and Text for Facebook",
            "type": "main",
            "index": 0
          }
        ],
        [],
        [
          {
            "node": "Build Email Meta",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Id and Text for SDR": {
      "main": [
        [
          {
            "node": "SDR Parsing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Id and Text for Windowrevival.NET": {
      "main": [
        [
          {
            "node": "Windowrevival.NET Parsing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Id and Text for Facebook": {
      "main": [
        [
          {
            "node": "FB Parsing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Preserve attachments": {
      "main": [
        [
          {
            "node": "Router",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has PDF?": {
      "main": [
        [],
        []
      ]
    },
    "Extract PDF text": {
      "main": [
        []
      ]
    },
    "Get email meta for WorkOrder/QuoteOrder": {
      "main": [
        []
      ]
    },
    "Extract from File": {
      "main": [
        [
          {
            "node": "Group the PDF text",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "No PDF": {
      "main": [
        []
      ]
    },
    "Split PDFs (keep meta)": {
      "main": [
        [
          {
            "node": "Extract from File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Email Meta": {
      "main": [
        [
          {
            "node": "Split PDFs (keep meta)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge TRUE+FALSE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge TRUE+FALSE": {
      "main": [
        [
          {
            "node": "Normalize pdf fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create NO-PDF list from Build Email Meta": {
      "main": [
        []
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Email Work Order Parsing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Group the PDF text": {
      "main": [
        [
          {
            "node": "Merge TRUE+FALSE",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Normalize pdf fields": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Email Work Order Parsing": {
      "main": [
        [
          {
            "node": "Append row in sheet",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false,
    "errorWorkflow": "b4cFEFv1eFePOnMh"
  },
  "staticData": {
    "node:Gmail Trigger": {
      "Gmail Trigger": {
        "lastTimeChecked": 1763427141,
        "possibleDuplicates": [
          "19a9472ca8f2fab6",
          "19a946dfe0b61dd3",
          "19a946bd84f6be6e",
          "19a946b0458f4fcf",
          "19a9469cc2a83387",
          "19a9468af00ed599",
          "19a9466cf92938d4",
          "19a945fd86ef412e",
          "19a945eb4bb2f4a8",
          "19a945767d761512",
          "19a9453a3ff698d7",
          "19a94516453f84b8",
          "19a944f7ba65087e",
          "19a944d0f69bd9ed",
          "19a944c587c61090",
          "19a944b1a9d19c7c",
          "19a944a718ca7c8d",
          "19a944939e627a34",
          "19a944784862f3f7",
          "19a94442ba7fdc2e",
          "19a94424a67cdfcd",
          "19a9440842ed2861",
          "19a943ea0493a8f2",
          "19a943cf0ec68dba",
          "19a943ca04569d7f",
          "19a9438df3d9db76",
          "19a94373ea78dc3b",
          "19a943261e82b3c3",
          "19a9429a0936ce4b",
          "19a94236a8815c51",
          "19a9421fbaaa3ea7",
          "19a941d5d1790060"
        ]
      }
    },
    "node:Trigger every 1 minute": {
      "recurrenceRules": []
    },
    "node:Trigger every 5 minute": {
      "recurrenceRules": []
    }
  },
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "pinData": {
    "Trigger every 5 minute": [
      {
        "json": {
          "timestamp": "2026-01-27T10:30:10.688+10:00",
          "Readable date": "January 27th 2026, 10:30:10 am",
          "Readable time": "10:30:10 am",
          "Day of week": "Tuesday",
          "Year": "2026",
          "Month": "January",
          "Day of month": "27",
          "Hour": "10",
          "Minute": "30",
          "Second": "10",
          "Timezone": "Australia/Brisbane (UTC+10:00)"
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "versionId": "fa0779ad-d8ae-47a3-9c56-2a169d61ff66",
  "activeVersionId": null,
  "versionCounter": 532,
  "triggerCount": 1,
  "shared": [
    {
      "updatedAt": "2026-01-18T11:08:16.560Z",
      "createdAt": "2026-01-18T11:08:16.560Z",
      "role": "workflow:owner",
      "workflowId": "F5Apqb3pbE0Lcfby",
      "projectId": "6TsYTzg0HY92xH2K",
      "project": {
        "updatedAt": "2025-11-14T08:33:27.896Z",
        "createdAt": "2025-11-14T07:49:25.938Z",
        "id": "6TsYTzg0HY92xH2K",
        "name": "Christine Kam <windowrevival@gmail.com>",
        "type": "personal",
        "icon": null,
        "description": null,
        "creatorId": "bc31a112-3ed8-48ca-b94c-7225571c3d7b",
        "projectRelations": [
          {
            "updatedAt": "2025-11-14T07:49:25.938Z",
            "createdAt": "2025-11-14T07:49:25.938Z",
            "userId": "bc31a112-3ed8-48ca-b94c-7225571c3d7b",
            "projectId": "6TsYTzg0HY92xH2K",
            "user": {
              "updatedAt": "2026-02-10T14:01:06.000Z",
              "createdAt": "2025-11-14T07:49:14.641Z",
              "id": "bc31a112-3ed8-48ca-b94c-7225571c3d7b",
              "email": "windowrevival@gmail.com",
              "firstName": "Christine",
              "lastName": "Kam",
              "personalizationAnswers": {
                "version": "v4",
                "personalization_survey_submitted_at": "2025-11-14T08:34:38.735Z",
                "personalization_survey_n8n_version": "1.119.1",
                "automationGoalDevops": [
                  "reporting",
                  "other"
                ],
                "automationGoalDevopsOther": "Automate all apps",
                "companySize": "<20",
                "companyType": "systems-integrator",
                "role": "it",
                "reportedSource": "google"
              },
              "settings": {
                "userActivated": true,
                "easyAIWorkflowOnboarded": true,
                "firstSuccessfulWorkflowId": "ZwjGOdSLvNlPoB1E",
                "userActivatedAt": 1763281773859,
                "npsSurvey": {
                  "responded": true,
                  "lastShownAt": 1763554974919
                }
              },
              "disabled": false,
              "mfaEnabled": false,
              "lastActiveAt": "2026-02-11",
              "isPending": false
            }
          }
        ]
      }
    }
  ],
  "tags": [
    {
      "updatedAt": "2025-11-25T13:05:18.454Z",
      "createdAt": "2025-11-25T13:05:18.454Z",
      "id": "xn6seEX74pkTOLqC",
      "name": "@lead"
    }
  ],
  "activeVersion": null
}